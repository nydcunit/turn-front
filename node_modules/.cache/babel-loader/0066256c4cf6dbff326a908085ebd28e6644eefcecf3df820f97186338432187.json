{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReactNative = void 0;\nconst sdpTransform = require(\"sdp-transform\");\nconst Logger_1 = require(\"../Logger\");\nconst errors_1 = require(\"../errors\");\nconst utils = require(\"../utils\");\nconst ortc = require(\"../ortc\");\nconst sdpCommonUtils = require(\"./sdp/commonUtils\");\nconst sdpPlanBUtils = require(\"./sdp/planBUtils\");\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst logger = new Logger_1.Logger('ReactNative');\nconst NAME = 'ReactNative';\nconst SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\nclass ReactNative extends HandlerInterface_1.HandlerInterface {\n  // Handler direction.\n  _direction;\n  // Remote SDP handler.\n  _remoteSdp;\n  // Generic sending RTP parameters for audio and video.\n  _sendingRtpParametersByKind;\n  // Generic sending RTP parameters for audio and video suitable for the SDP\n  // remote answer.\n  _sendingRemoteRtpParametersByKind;\n  // Initial server side DTLS role. If not 'auto', it will force the opposite\n  // value in client side.\n  _forcedLocalDtlsRole;\n  // RTCPeerConnection instance.\n  _pc;\n  // Local stream for sending.\n  _sendStream = new MediaStream();\n  // Map of sending MediaStreamTracks indexed by localId.\n  _mapSendLocalIdTrack = new Map();\n  // Next sending localId.\n  _nextSendLocalId = 0;\n  // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n  // Value is an Object with mid, rtpParameters and rtpReceiver.\n  _mapRecvLocalIdInfo = new Map();\n  // Whether a DataChannel m=application section has been created.\n  _hasDataChannelMediaSection = false;\n  // Sending DataChannel id value counter. Incremented for each new DataChannel.\n  _nextSendSctpStreamId = 0;\n  // Got transport local and remote parameters.\n  _transportReady = false;\n  /**\n   * Creates a factory function.\n   */\n  static createFactory() {\n    return () => new ReactNative();\n  }\n  constructor() {\n    super();\n  }\n  get name() {\n    return NAME;\n  }\n  close() {\n    logger.debug('close()');\n    // Free/dispose native MediaStream but DO NOT free/dispose native\n    // MediaStreamTracks (that is parent's business).\n    // @ts-expect-error --- Proprietary API in react-native-webrtc.\n    this._sendStream.release(/* releaseTracks */false);\n    // Close RTCPeerConnection.\n    if (this._pc) {\n      try {\n        this._pc.close();\n      } catch (error) {}\n    }\n    this.emit('@close');\n  }\n  async getNativeRtpCapabilities() {\n    logger.debug('getNativeRtpCapabilities()');\n    const pc = new RTCPeerConnection({\n      iceServers: [],\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'plan-b'\n    });\n    try {\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      try {\n        pc.close();\n      } catch (error) {}\n      const sdpObject = sdpTransform.parse(offer.sdp);\n      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n        sdpObject\n      });\n      return nativeRtpCapabilities;\n    } catch (error) {\n      try {\n        pc.close();\n      } catch (error2) {}\n      throw error;\n    }\n  }\n  async getNativeSctpCapabilities() {\n    logger.debug('getNativeSctpCapabilities()');\n    return {\n      numStreams: SCTP_NUM_STREAMS\n    };\n  }\n  run({\n    direction,\n    iceParameters,\n    iceCandidates,\n    dtlsParameters,\n    sctpParameters,\n    iceServers,\n    iceTransportPolicy,\n    additionalSettings,\n    proprietaryConstraints,\n    extendedRtpCapabilities\n  }) {\n    logger.debug('run()');\n    this._direction = direction;\n    this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      planB: true\n    });\n    this._sendingRtpParametersByKind = {\n      audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._sendingRemoteRtpParametersByKind = {\n      audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n    };\n    if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n      this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';\n    }\n    this._pc = new RTCPeerConnection({\n      iceServers: iceServers ?? [],\n      iceTransportPolicy: iceTransportPolicy ?? 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'plan-b',\n      ...additionalSettings\n    }, proprietaryConstraints);\n    this._pc.addEventListener('icegatheringstatechange', () => {\n      this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n    });\n    this._pc.addEventListener('icecandidateerror', event => {\n      this.emit('@icecandidateerror', event);\n    });\n    if (this._pc.connectionState) {\n      this._pc.addEventListener('connectionstatechange', () => {\n        this.emit('@connectionstatechange', this._pc.connectionState);\n      });\n    } else {\n      this._pc.addEventListener('iceconnectionstatechange', () => {\n        logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n        switch (this._pc.iceConnectionState) {\n          case 'checking':\n            {\n              this.emit('@connectionstatechange', 'connecting');\n              break;\n            }\n          case 'connected':\n          case 'completed':\n            {\n              this.emit('@connectionstatechange', 'connected');\n              break;\n            }\n          case 'failed':\n            {\n              this.emit('@connectionstatechange', 'failed');\n              break;\n            }\n          case 'disconnected':\n            {\n              this.emit('@connectionstatechange', 'disconnected');\n              break;\n            }\n          case 'closed':\n            {\n              this.emit('@connectionstatechange', 'closed');\n              break;\n            }\n        }\n      });\n    }\n  }\n  async updateIceServers(iceServers) {\n    logger.debug('updateIceServers()');\n    const configuration = this._pc.getConfiguration();\n    configuration.iceServers = iceServers;\n    this._pc.setConfiguration(configuration);\n  }\n  async restartIce(iceParameters) {\n    logger.debug('restartIce()');\n    // Provide the remote SDP handler with new remote ICE parameters.\n    this._remoteSdp.updateIceParameters(iceParameters);\n    if (!this._transportReady) {\n      return;\n    }\n    if (this._direction === 'send') {\n      const offer = await this._pc.createOffer({\n        iceRestart: true\n      });\n      logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n    } else {\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n    }\n  }\n  async getTransportStats() {\n    return this._pc.getStats();\n  }\n  async send({\n    track,\n    encodings,\n    codecOptions,\n    codec\n  }) {\n    this.assertSendDirection();\n    logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n    if (codec) {\n      logger.warn('send() | codec selection is not available in %s handler', this.name);\n    }\n    this._sendStream.addTrack(track);\n    this._pc.addStream(this._sendStream);\n    let offer = await this._pc.createOffer();\n    let localSdpObject = sdpTransform.parse(offer.sdp);\n    // @ts-expect-error --- sdpTransform.SessionDescription type doesn't\n    // define extmapAllowMixed field.\n    if (localSdpObject.extmapAllowMixed) {\n      this._remoteSdp.setSessionExtmapAllowMixed();\n    }\n    let offerMediaObject;\n    const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n    const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n    if (!this._transportReady) {\n      await this.setupTransport({\n        localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n        localSdpObject\n      });\n    }\n    if (track.kind === 'video' && encodings && encodings.length > 1) {\n      logger.debug('send() | enabling simulcast');\n      localSdpObject = sdpTransform.parse(offer.sdp);\n      offerMediaObject = localSdpObject.media.find(m => m.type === 'video');\n      sdpPlanBUtils.addLegacySimulcast({\n        offerMediaObject,\n        track,\n        numStreams: encodings.length\n      });\n      offer = {\n        type: 'offer',\n        sdp: sdpTransform.write(localSdpObject)\n      };\n    }\n    logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    offerMediaObject = localSdpObject.media.find(m => m.type === track.kind);\n    // Set RTCP CNAME.\n    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n      offerMediaObject\n    });\n    // Set RTP encodings.\n    sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n      offerMediaObject,\n      track\n    });\n    // Complete encodings with given values.\n    if (encodings) {\n      for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n        if (encodings[idx]) {\n          Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n        }\n      }\n    }\n    // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n    // each encoding.\n    if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n      for (const encoding of sendingRtpParameters.encodings) {\n        encoding.scalabilityMode = 'L1T3';\n      }\n    }\n    this._remoteSdp.send({\n      offerMediaObject,\n      offerRtpParameters: sendingRtpParameters,\n      answerRtpParameters: sendingRemoteRtpParameters,\n      codecOptions\n    });\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n    const localId = String(this._nextSendLocalId);\n    this._nextSendLocalId++;\n    // Insert into the map.\n    this._mapSendLocalIdTrack.set(localId, track);\n    return {\n      localId: localId,\n      rtpParameters: sendingRtpParameters\n    };\n  }\n  async stopSending(localId) {\n    this.assertSendDirection();\n    logger.debug('stopSending() [localId:%s]', localId);\n    const track = this._mapSendLocalIdTrack.get(localId);\n    if (!track) {\n      throw new Error('track not found');\n    }\n    this._mapSendLocalIdTrack.delete(localId);\n    this._sendStream.removeTrack(track);\n    this._pc.addStream(this._sendStream);\n    const offer = await this._pc.createOffer();\n    logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n    try {\n      await this._pc.setLocalDescription(offer);\n    } catch (error) {\n      // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n      // \"Failed to create channels\". If so, ignore it.\n      if (this._sendStream.getTracks().length === 0) {\n        logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n        return;\n      }\n      throw error;\n    }\n    if (this._pc.signalingState === 'stable') {\n      return;\n    }\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async pauseSending(localId) {\n    // Unimplemented.\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async resumeSending(localId) {\n    // Unimplemented.\n  }\n  async replaceTrack(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  localId,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  track) {\n    throw new errors_1.UnsupportedError('not implemented');\n  }\n  async setMaxSpatialLayer(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  localId,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  spatialLayer) {\n    throw new errors_1.UnsupportedError('not implemented');\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async setRtpEncodingParameters(localId, params) {\n    throw new errors_1.UnsupportedError('not implemented');\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async getSenderStats(localId) {\n    throw new errors_1.UnsupportedError('not implemented');\n  }\n  async sendDataChannel({\n    ordered,\n    maxPacketLifeTime,\n    maxRetransmits,\n    label,\n    protocol\n  }) {\n    this.assertSendDirection();\n    const options = {\n      negotiated: true,\n      id: this._nextSendSctpStreamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmitTime: maxPacketLifeTime,\n      // NOTE: Old spec.\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('sendDataChannel() [options:%o]', options);\n    const dataChannel = this._pc.createDataChannel(label, options);\n    // Increase next id.\n    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n    // If this is the first DataChannel we need to create the SDP answer with\n    // m=application section.\n    if (!this._hasDataChannelMediaSection) {\n      const offer = await this._pc.createOffer();\n      const localSdpObject = sdpTransform.parse(offer.sdp);\n      const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');\n      if (!this._transportReady) {\n        await this.setupTransport({\n          localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n          localSdpObject\n        });\n      }\n      logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      this._remoteSdp.sendSctpAssociation({\n        offerMediaObject\n      });\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n    const sctpStreamParameters = {\n      streamId: options.id,\n      ordered: options.ordered,\n      maxPacketLifeTime: options.maxPacketLifeTime,\n      maxRetransmits: options.maxRetransmits\n    };\n    return {\n      dataChannel,\n      sctpStreamParameters\n    };\n  }\n  async receive(optionsList) {\n    this.assertRecvDirection();\n    const results = [];\n    const mapStreamId = new Map();\n    for (const options of optionsList) {\n      const {\n        trackId,\n        kind,\n        rtpParameters\n      } = options;\n      logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n      const mid = kind;\n      let streamId = options.streamId ?? rtpParameters.rtcp.cname;\n      // NOTE: In React-Native we cannot reuse the same remote MediaStream for new\n      // remote tracks. This is because react-native-webrtc does not react on new\n      // tracks generated within already existing streams, so force the streamId\n      // to be different. See:\n      // https://github.com/react-native-webrtc/react-native-webrtc/issues/401\n      logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');\n      streamId += `-hack-${utils.generateRandomNumber()}`;\n      mapStreamId.set(trackId, streamId);\n      this._remoteSdp.receive({\n        mid,\n        kind,\n        offerRtpParameters: rtpParameters,\n        streamId,\n        trackId\n      });\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    let answer = await this._pc.createAnswer();\n    const localSdpObject = sdpTransform.parse(answer.sdp);\n    for (const options of optionsList) {\n      const {\n        kind,\n        rtpParameters\n      } = options;\n      const mid = kind;\n      const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === mid);\n      // May need to modify codec parameters in the answer based on codec\n      // parameters in the offer.\n      sdpCommonUtils.applyCodecParameters({\n        offerRtpParameters: rtpParameters,\n        answerMediaObject\n      });\n    }\n    answer = {\n      type: 'answer',\n      sdp: sdpTransform.write(localSdpObject)\n    };\n    if (!this._transportReady) {\n      await this.setupTransport({\n        localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n        localSdpObject\n      });\n    }\n    logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n    for (const options of optionsList) {\n      const {\n        kind,\n        trackId,\n        rtpParameters\n      } = options;\n      const localId = trackId;\n      const mid = kind;\n      const streamId = mapStreamId.get(trackId);\n      const stream = this._pc.getRemoteStreams().find(s => s.id === streamId);\n      const track = stream.getTrackById(localId);\n      if (!track) {\n        throw new Error('remote track not found');\n      }\n      // Insert into the map.\n      this._mapRecvLocalIdInfo.set(localId, {\n        mid,\n        rtpParameters\n      });\n      results.push({\n        localId,\n        track\n      });\n    }\n    return results;\n  }\n  async stopReceiving(localIds) {\n    this.assertRecvDirection();\n    for (const localId of localIds) {\n      logger.debug('stopReceiving() [localId:%s]', localId);\n      const {\n        mid,\n        rtpParameters\n      } = this._mapRecvLocalIdInfo.get(localId) ?? {};\n      // Remove from the map.\n      this._mapRecvLocalIdInfo.delete(localId);\n      this._remoteSdp.planBStopReceiving({\n        mid: mid,\n        offerRtpParameters: rtpParameters\n      });\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    const answer = await this._pc.createAnswer();\n    logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n  }\n  async pauseReceiving(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  localIds) {\n    // Unimplemented.\n  }\n  async resumeReceiving(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  localIds) {\n    // Unimplemented.\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async getReceiverStats(localId) {\n    throw new errors_1.UnsupportedError('not implemented');\n  }\n  async receiveDataChannel({\n    sctpStreamParameters,\n    label,\n    protocol\n  }) {\n    this.assertRecvDirection();\n    const {\n      streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits\n    } = sctpStreamParameters;\n    const options = {\n      negotiated: true,\n      id: streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmitTime: maxPacketLifeTime,\n      // NOTE: Old spec.\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('receiveDataChannel() [options:%o]', options);\n    const dataChannel = this._pc.createDataChannel(label, options);\n    // If this is the first DataChannel we need to create the SDP offer with\n    // m=application section.\n    if (!this._hasDataChannelMediaSection) {\n      this._remoteSdp.receiveSctpAssociation({\n        oldDataChannelSpec: true\n      });\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      if (!this._transportReady) {\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        await this.setupTransport({\n          localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n          localSdpObject\n        });\n      }\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n    return {\n      dataChannel\n    };\n  }\n  async setupTransport({\n    localDtlsRole,\n    localSdpObject\n  }) {\n    if (!localSdpObject) {\n      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    }\n    // Get our local DTLS parameters.\n    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n      sdpObject: localSdpObject\n    });\n    // Set our DTLS role.\n    dtlsParameters.role = localDtlsRole;\n    // Update the remote DTLS role in the SDP.\n    this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n    // Need to tell the remote transport about our parameters.\n    await new Promise((resolve, reject) => {\n      this.safeEmit('@connect', {\n        dtlsParameters\n      }, resolve, reject);\n    });\n    this._transportReady = true;\n  }\n  assertSendDirection() {\n    if (this._direction !== 'send') {\n      throw new Error('method can just be called for handlers with \"send\" direction');\n    }\n  }\n  assertRecvDirection() {\n    if (this._direction !== 'recv') {\n      throw new Error('method can just be called for handlers with \"recv\" direction');\n    }\n  }\n}\nexports.ReactNative = ReactNative;","map":{"version":3,"names":["Object","defineProperty","exports","value","ReactNative","sdpTransform","require","Logger_1","errors_1","utils","ortc","sdpCommonUtils","sdpPlanBUtils","HandlerInterface_1","RemoteSdp_1","logger","Logger","NAME","SCTP_NUM_STREAMS","OS","MIS","HandlerInterface","_direction","_remoteSdp","_sendingRtpParametersByKind","_sendingRemoteRtpParametersByKind","_forcedLocalDtlsRole","_pc","_sendStream","MediaStream","_mapSendLocalIdTrack","Map","_nextSendLocalId","_mapRecvLocalIdInfo","_hasDataChannelMediaSection","_nextSendSctpStreamId","_transportReady","createFactory","constructor","name","close","debug","release","error","emit","getNativeRtpCapabilities","pc","RTCPeerConnection","iceServers","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","sdpObject","parse","sdp","nativeRtpCapabilities","extractRtpCapabilities","error2","getNativeSctpCapabilities","numStreams","run","direction","iceParameters","iceCandidates","dtlsParameters","sctpParameters","additionalSettings","proprietaryConstraints","extendedRtpCapabilities","RemoteSdp","planB","audio","getSendingRtpParameters","video","getSendingRemoteRtpParameters","role","addEventListener","iceGatheringState","event","connectionState","warn","iceConnectionState","updateIceServers","configuration","getConfiguration","setConfiguration","restartIce","updateIceParameters","iceRestart","setLocalDescription","answer","type","getSdp","setRemoteDescription","createAnswer","getTransportStats","getStats","send","track","encodings","codecOptions","codec","assertSendDirection","kind","id","addTrack","addStream","localSdpObject","extmapAllowMixed","setSessionExtmapAllowMixed","offerMediaObject","sendingRtpParameters","clone","codecs","reduceCodecs","sendingRemoteRtpParameters","setupTransport","localDtlsRole","length","media","find","m","addLegacySimulcast","write","localDescription","rtcp","cname","getCname","getRtpEncodings","idx","assign","mimeType","toLowerCase","encoding","scalabilityMode","offerRtpParameters","answerRtpParameters","localId","String","set","rtpParameters","stopSending","get","Error","delete","removeTrack","getTracks","toString","signalingState","pauseSending","resumeSending","replaceTrack","UnsupportedError","setMaxSpatialLayer","spatialLayer","setRtpEncodingParameters","params","getSenderStats","sendDataChannel","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","options","negotiated","maxRetransmitTime","dataChannel","createDataChannel","sendSctpAssociation","sctpStreamParameters","streamId","receive","optionsList","assertRecvDirection","results","mapStreamId","trackId","mid","generateRandomNumber","answerMediaObject","applyCodecParameters","stream","getRemoteStreams","s","getTrackById","push","stopReceiving","localIds","planBStopReceiving","pauseReceiving","resumeReceiving","getReceiverStats","receiveDataChannel","receiveSctpAssociation","oldDataChannelSpec","extractDtlsParameters","updateDtlsRole","Promise","resolve","reject","safeEmit"],"sources":["/Users/user/turn/turn-front/node_modules/mediasoup-client/lib/handlers/ReactNative.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReactNative = void 0;\nconst sdpTransform = require(\"sdp-transform\");\nconst Logger_1 = require(\"../Logger\");\nconst errors_1 = require(\"../errors\");\nconst utils = require(\"../utils\");\nconst ortc = require(\"../ortc\");\nconst sdpCommonUtils = require(\"./sdp/commonUtils\");\nconst sdpPlanBUtils = require(\"./sdp/planBUtils\");\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst logger = new Logger_1.Logger('ReactNative');\nconst NAME = 'ReactNative';\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass ReactNative extends HandlerInterface_1.HandlerInterface {\n    // Handler direction.\n    _direction;\n    // Remote SDP handler.\n    _remoteSdp;\n    // Generic sending RTP parameters for audio and video.\n    _sendingRtpParametersByKind;\n    // Generic sending RTP parameters for audio and video suitable for the SDP\n    // remote answer.\n    _sendingRemoteRtpParametersByKind;\n    // Initial server side DTLS role. If not 'auto', it will force the opposite\n    // value in client side.\n    _forcedLocalDtlsRole;\n    // RTCPeerConnection instance.\n    _pc;\n    // Local stream for sending.\n    _sendStream = new MediaStream();\n    // Map of sending MediaStreamTracks indexed by localId.\n    _mapSendLocalIdTrack = new Map();\n    // Next sending localId.\n    _nextSendLocalId = 0;\n    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n    // Value is an Object with mid, rtpParameters and rtpReceiver.\n    _mapRecvLocalIdInfo = new Map();\n    // Whether a DataChannel m=application section has been created.\n    _hasDataChannelMediaSection = false;\n    // Sending DataChannel id value counter. Incremented for each new DataChannel.\n    _nextSendSctpStreamId = 0;\n    // Got transport local and remote parameters.\n    _transportReady = false;\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new ReactNative();\n    }\n    constructor() {\n        super();\n    }\n    get name() {\n        return NAME;\n    }\n    close() {\n        logger.debug('close()');\n        // Free/dispose native MediaStream but DO NOT free/dispose native\n        // MediaStreamTracks (that is parent's business).\n        // @ts-expect-error --- Proprietary API in react-native-webrtc.\n        this._sendStream.release(/* releaseTracks */ false);\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true,\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers ?? [],\n            iceTransportPolicy: iceTransportPolicy ?? 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        this._pc.addEventListener('icecandidateerror', (event) => {\n            this.emit('@icecandidateerror', event);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addStream(this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        // @ts-expect-error --- sdpTransform.SessionDescription type doesn't\n        // define extmapAllowMixed field.\n        if (localSdpObject.extmapAllowMixed) {\n            this._remoteSdp.setSessionExtmapAllowMixed();\n        }\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n            offerMediaObject,\n            track,\n        });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx]) {\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                }\n            }\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'L1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        // Insert into the map.\n        this._mapSendLocalIdTrack.set(localId, track);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const track = this._mapSendLocalIdTrack.get(localId);\n        if (!track) {\n            throw new Error('track not found');\n        }\n        this._mapSendLocalIdTrack.delete(localId);\n        this._sendStream.removeTrack(track);\n        this._pc.addStream(this._sendStream);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable') {\n            return;\n        }\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    track) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async setMaxSpatialLayer(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    spatialLayer) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setRtpEncodingParameters(localId, params) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getSenderStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertRecvDirection();\n        const results = [];\n        const mapStreamId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const mid = kind;\n            let streamId = options.streamId ?? rtpParameters.rtcp.cname;\n            // NOTE: In React-Native we cannot reuse the same remote MediaStream for new\n            // remote tracks. This is because react-native-webrtc does not react on new\n            // tracks generated within already existing streams, so force the streamId\n            // to be different. See:\n            // https://github.com/react-native-webrtc/react-native-webrtc/issues/401\n            logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');\n            streamId += `-hack-${utils.generateRandomNumber()}`;\n            mapStreamId.set(trackId, streamId);\n            this._remoteSdp.receive({\n                mid,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { kind, rtpParameters } = options;\n            const mid = kind;\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { kind, trackId, rtpParameters } = options;\n            const localId = trackId;\n            const mid = kind;\n            const streamId = mapStreamId.get(trackId);\n            const stream = this._pc\n                .getRemoteStreams()\n                .find((s) => s.id === streamId);\n            const track = stream.getTrackById(localId);\n            if (!track) {\n                throw new Error('remote track not found');\n            }\n            // Insert into the map.\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\n            results.push({ localId, track });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};\n            // Remove from the map.\n            this._mapRecvLocalIdInfo.delete(localId);\n            this._remoteSdp.planBStopReceiving({\n                mid: mid,\n                offerRtpParameters: rtpParameters,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getReceiverStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.ReactNative = ReactNative;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}