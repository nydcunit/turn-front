{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Firefox120 = void 0;\nconst sdpTransform = require(\"sdp-transform\");\nconst Logger_1 = require(\"../Logger\");\nconst errors_1 = require(\"../errors\");\nconst utils = require(\"../utils\");\nconst ortc = require(\"../ortc\");\nconst sdpCommonUtils = require(\"./sdp/commonUtils\");\nconst sdpUnifiedPlanUtils = require(\"./sdp/unifiedPlanUtils\");\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst scalabilityModes_1 = require(\"../scalabilityModes\");\nconst logger = new Logger_1.Logger('Firefox120');\nconst NAME = 'Firefox120';\nconst SCTP_NUM_STREAMS = {\n  OS: 16,\n  MIS: 2048\n};\nclass Firefox120 extends HandlerInterface_1.HandlerInterface {\n  // Closed flag.\n  _closed = false;\n  // Handler direction.\n  _direction;\n  // Remote SDP handler.\n  _remoteSdp;\n  // Generic sending RTP parameters for audio and video.\n  _sendingRtpParametersByKind;\n  // Generic sending RTP parameters for audio and video suitable for the SDP\n  // remote answer.\n  _sendingRemoteRtpParametersByKind;\n  // RTCPeerConnection instance.\n  _pc;\n  // Map of RTCTransceivers indexed by MID.\n  _mapMidTransceiver = new Map();\n  // Local stream for sending.\n  _sendStream = new MediaStream();\n  // Whether a DataChannel m=application section has been created.\n  _hasDataChannelMediaSection = false;\n  // Sending DataChannel id value counter. Incremented for each new DataChannel.\n  _nextSendSctpStreamId = 0;\n  // Got transport local and remote parameters.\n  _transportReady = false;\n  /**\n   * Creates a factory function.\n   */\n  static createFactory() {\n    return () => new Firefox120();\n  }\n  constructor() {\n    super();\n  }\n  get name() {\n    return NAME;\n  }\n  close() {\n    logger.debug('close()');\n    if (this._closed) {\n      return;\n    }\n    this._closed = true;\n    // Close RTCPeerConnection.\n    if (this._pc) {\n      try {\n        this._pc.close();\n      } catch (error) {}\n    }\n    this.emit('@close');\n  }\n  async getNativeRtpCapabilities() {\n    logger.debug('getNativeRtpCapabilities()');\n    const pc = new RTCPeerConnection({\n      iceServers: [],\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require'\n    });\n    // NOTE: We need to add a real video track to get the RID extension mapping,\n    // otherwiser Firefox doesn't include it in the SDP.\n    const canvas = document.createElement('canvas');\n    // NOTE: Otherwise Firefox fails in next line.\n    canvas.getContext('2d');\n    const fakeStream = canvas.captureStream();\n    const fakeVideoTrack = fakeStream.getVideoTracks()[0];\n    try {\n      pc.addTransceiver('audio', {\n        direction: 'sendrecv'\n      });\n      pc.addTransceiver(fakeVideoTrack, {\n        direction: 'sendrecv',\n        sendEncodings: [{\n          rid: 'r0',\n          maxBitrate: 100000\n        }, {\n          rid: 'r1',\n          maxBitrate: 500000\n        }]\n      });\n      const offer = await pc.createOffer();\n      try {\n        canvas.remove();\n      } catch (error) {}\n      try {\n        fakeVideoTrack.stop();\n      } catch (error) {}\n      try {\n        pc.close();\n      } catch (error) {}\n      const sdpObject = sdpTransform.parse(offer.sdp);\n      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n        sdpObject\n      });\n      return nativeRtpCapabilities;\n    } catch (error) {\n      try {\n        canvas.remove();\n      } catch (error2) {}\n      try {\n        fakeVideoTrack.stop();\n      } catch (error2) {}\n      try {\n        pc.close();\n      } catch (error2) {}\n      throw error;\n    }\n  }\n  async getNativeSctpCapabilities() {\n    logger.debug('getNativeSctpCapabilities()');\n    return {\n      numStreams: SCTP_NUM_STREAMS\n    };\n  }\n  run({\n    direction,\n    iceParameters,\n    iceCandidates,\n    dtlsParameters,\n    sctpParameters,\n    iceServers,\n    iceTransportPolicy,\n    additionalSettings,\n    proprietaryConstraints,\n    extendedRtpCapabilities\n  }) {\n    this.assertNotClosed();\n    logger.debug('run()');\n    this._direction = direction;\n    this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters\n    });\n    this._sendingRtpParametersByKind = {\n      audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._sendingRemoteRtpParametersByKind = {\n      audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._pc = new RTCPeerConnection({\n      iceServers: iceServers ?? [],\n      iceTransportPolicy: iceTransportPolicy ?? 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require',\n      ...additionalSettings\n    }, proprietaryConstraints);\n    this._pc.addEventListener('icegatheringstatechange', () => {\n      this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n    });\n    this._pc.addEventListener('icecandidateerror', event => {\n      this.emit('@icecandidateerror', event);\n    });\n    if (this._pc.connectionState) {\n      this._pc.addEventListener('connectionstatechange', () => {\n        this.emit('@connectionstatechange', this._pc.connectionState);\n      });\n    } else {\n      this._pc.addEventListener('iceconnectionstatechange', () => {\n        logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n        switch (this._pc.iceConnectionState) {\n          case 'checking':\n            {\n              this.emit('@connectionstatechange', 'connecting');\n              break;\n            }\n          case 'connected':\n          case 'completed':\n            {\n              this.emit('@connectionstatechange', 'connected');\n              break;\n            }\n          case 'failed':\n            {\n              this.emit('@connectionstatechange', 'failed');\n              break;\n            }\n          case 'disconnected':\n            {\n              this.emit('@connectionstatechange', 'disconnected');\n              break;\n            }\n          case 'closed':\n            {\n              this.emit('@connectionstatechange', 'closed');\n              break;\n            }\n        }\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async updateIceServers(iceServers) {\n    this.assertNotClosed();\n    // NOTE: Firefox does not implement pc.setConfiguration().\n    throw new errors_1.UnsupportedError('not supported');\n  }\n  async restartIce(iceParameters) {\n    this.assertNotClosed();\n    logger.debug('restartIce()');\n    // Provide the remote SDP handler with new remote ICE parameters.\n    this._remoteSdp.updateIceParameters(iceParameters);\n    if (!this._transportReady) {\n      return;\n    }\n    if (this._direction === 'send') {\n      const offer = await this._pc.createOffer({\n        iceRestart: true\n      });\n      logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n    } else {\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n    }\n  }\n  async getTransportStats() {\n    this.assertNotClosed();\n    return this._pc.getStats();\n  }\n  async send({\n    track,\n    encodings,\n    codecOptions,\n    codec,\n    onRtpSender\n  }) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n    if (encodings && encodings.length > 1) {\n      encodings.forEach((encoding, idx) => {\n        encoding.rid = `r${idx}`;\n      });\n    }\n    const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n    // This may throw.\n    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n    const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n    // This may throw.\n    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n    // NOTE: Firefox fails sometimes to properly anticipate the closed media\n    // section that it should use, so don't reuse closed media sections.\n    //   https://github.com/versatica/mediasoup-client/issues/104\n    //\n    // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();\n    const transceiver = this._pc.addTransceiver(track, {\n      direction: 'sendonly',\n      streams: [this._sendStream],\n      sendEncodings: encodings\n    });\n    if (onRtpSender) {\n      onRtpSender(transceiver.sender);\n    }\n    const offer = await this._pc.createOffer();\n    let localSdpObject = sdpTransform.parse(offer.sdp);\n    // @ts-expect-error --- sdpTransform.SessionDescription type doesn't\n    // define extmapAllowMixed field.\n    if (localSdpObject.extmapAllowMixed) {\n      this._remoteSdp.setSessionExtmapAllowMixed();\n    }\n    // In Firefox use DTLS role client even if we are the \"offerer\" since\n    // Firefox does not respect ICE-Lite.\n    if (!this._transportReady) {\n      await this.setupTransport({\n        localDtlsRole: 'client',\n        localSdpObject\n      });\n    }\n    const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);\n    logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    // We can now get the transceiver.mid.\n    const localId = transceiver.mid;\n    // Set MID.\n    sendingRtpParameters.mid = localId;\n    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];\n    // Set RTCP CNAME.\n    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n      offerMediaObject\n    });\n    // Set RTP encodings by parsing the SDP offer if no encodings are given.\n    if (!encodings) {\n      sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n        offerMediaObject\n      });\n    }\n    // Set RTP encodings by parsing the SDP offer and complete them with given\n    // one if just a single encoding has been given.\n    else if (encodings.length === 1) {\n      const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n        offerMediaObject\n      });\n      Object.assign(newEncodings[0], encodings[0]);\n      sendingRtpParameters.encodings = newEncodings;\n    }\n    // Otherwise if more than 1 encoding are given use them verbatim.\n    else {\n      sendingRtpParameters.encodings = encodings;\n    }\n    // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n    // each encoding.\n    if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n      for (const encoding of sendingRtpParameters.encodings) {\n        if (encoding.scalabilityMode) {\n          encoding.scalabilityMode = `L1T${layers.temporalLayers}`;\n        } else {\n          encoding.scalabilityMode = 'L1T3';\n        }\n      }\n    }\n    this._remoteSdp.send({\n      offerMediaObject,\n      offerRtpParameters: sendingRtpParameters,\n      answerRtpParameters: sendingRemoteRtpParameters,\n      codecOptions\n    });\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n    // Store in the map.\n    this._mapMidTransceiver.set(localId, transceiver);\n    return {\n      localId,\n      rtpParameters: sendingRtpParameters,\n      rtpSender: transceiver.sender\n    };\n  }\n  async stopSending(localId) {\n    this.assertSendDirection();\n    logger.debug('stopSending() [localId:%s]', localId);\n    if (this._closed) {\n      return;\n    }\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated transceiver not found');\n    }\n    void transceiver.sender.replaceTrack(null);\n    // NOTE: Cannot use stop() the transceiver due to the the note above in\n    // send() method.\n    // try\n    // {\n    // \ttransceiver.stop();\n    // }\n    // catch (error)\n    // {}\n    this._pc.removeTrack(transceiver.sender);\n    // NOTE: Cannot use closeMediaSection() due to the the note above in send()\n    // method.\n    // this._remoteSdp!.closeMediaSection(transceiver.mid);\n    this._remoteSdp.disableMediaSection(transceiver.mid);\n    const offer = await this._pc.createOffer();\n    logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n    this._mapMidTransceiver.delete(localId);\n  }\n  async pauseSending(localId) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    logger.debug('pauseSending() [localId:%s]', localId);\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated RTCRtpTransceiver not found');\n    }\n    transceiver.direction = 'inactive';\n    this._remoteSdp.pauseMediaSection(localId);\n    const offer = await this._pc.createOffer();\n    logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n  async resumeSending(localId) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    logger.debug('resumeSending() [localId:%s]', localId);\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated RTCRtpTransceiver not found');\n    }\n    transceiver.direction = 'sendonly';\n    this._remoteSdp.resumeSendingMediaSection(localId);\n    const offer = await this._pc.createOffer();\n    logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n  async replaceTrack(localId, track) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    if (track) {\n      logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n    } else {\n      logger.debug('replaceTrack() [localId:%s, no track]', localId);\n    }\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated RTCRtpTransceiver not found');\n    }\n    await transceiver.sender.replaceTrack(track);\n  }\n  async setMaxSpatialLayer(localId, spatialLayer) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated transceiver not found');\n    }\n    const parameters = transceiver.sender.getParameters();\n    parameters.encodings.forEach((encoding, idx) => {\n      if (idx <= spatialLayer) {\n        encoding.active = true;\n      } else {\n        encoding.active = false;\n      }\n    });\n    await transceiver.sender.setParameters(parameters);\n    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n    const offer = await this._pc.createOffer();\n    logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n  async setRtpEncodingParameters(localId, params) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated RTCRtpTransceiver not found');\n    }\n    const parameters = transceiver.sender.getParameters();\n    parameters.encodings.forEach((encoding, idx) => {\n      parameters.encodings[idx] = {\n        ...encoding,\n        ...params\n      };\n    });\n    await transceiver.sender.setParameters(parameters);\n    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n    const offer = await this._pc.createOffer();\n    logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n  async getSenderStats(localId) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated RTCRtpTransceiver not found');\n    }\n    return transceiver.sender.getStats();\n  }\n  async sendDataChannel({\n    ordered,\n    maxPacketLifeTime,\n    maxRetransmits,\n    label,\n    protocol\n  }) {\n    this.assertNotClosed();\n    this.assertSendDirection();\n    const options = {\n      negotiated: true,\n      id: this._nextSendSctpStreamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('sendDataChannel() [options:%o]', options);\n    const dataChannel = this._pc.createDataChannel(label, options);\n    // Increase next id.\n    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n    // If this is the first DataChannel we need to create the SDP answer with\n    // m=application section.\n    if (!this._hasDataChannelMediaSection) {\n      const offer = await this._pc.createOffer();\n      const localSdpObject = sdpTransform.parse(offer.sdp);\n      const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');\n      if (!this._transportReady) {\n        await this.setupTransport({\n          localDtlsRole: 'client',\n          localSdpObject\n        });\n      }\n      logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      this._remoteSdp.sendSctpAssociation({\n        offerMediaObject\n      });\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n    const sctpStreamParameters = {\n      streamId: options.id,\n      ordered: options.ordered,\n      maxPacketLifeTime: options.maxPacketLifeTime,\n      maxRetransmits: options.maxRetransmits\n    };\n    return {\n      dataChannel,\n      sctpStreamParameters\n    };\n  }\n  async receive(optionsList) {\n    this.assertNotClosed();\n    this.assertRecvDirection();\n    const results = [];\n    const mapLocalId = new Map();\n    for (const options of optionsList) {\n      const {\n        trackId,\n        kind,\n        rtpParameters,\n        streamId\n      } = options;\n      logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n      const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);\n      mapLocalId.set(trackId, localId);\n      this._remoteSdp.receive({\n        mid: localId,\n        kind,\n        offerRtpParameters: rtpParameters,\n        streamId: streamId ?? rtpParameters.rtcp.cname,\n        trackId\n      });\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    for (const options of optionsList) {\n      const {\n        trackId,\n        onRtpReceiver\n      } = options;\n      if (onRtpReceiver) {\n        const localId = mapLocalId.get(trackId);\n        const transceiver = this._pc.getTransceivers().find(t => t.mid === localId);\n        if (!transceiver) {\n          throw new Error('transceiver not found');\n        }\n        onRtpReceiver(transceiver.receiver);\n      }\n    }\n    let answer = await this._pc.createAnswer();\n    const localSdpObject = sdpTransform.parse(answer.sdp);\n    for (const options of optionsList) {\n      const {\n        trackId,\n        rtpParameters\n      } = options;\n      const localId = mapLocalId.get(trackId);\n      const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === localId);\n      // May need to modify codec parameters in the answer based on codec\n      // parameters in the offer.\n      sdpCommonUtils.applyCodecParameters({\n        offerRtpParameters: rtpParameters,\n        answerMediaObject\n      });\n      answer = {\n        type: 'answer',\n        sdp: sdpTransform.write(localSdpObject)\n      };\n    }\n    if (!this._transportReady) {\n      await this.setupTransport({\n        localDtlsRole: 'client',\n        localSdpObject\n      });\n    }\n    logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n    for (const options of optionsList) {\n      const {\n        trackId\n      } = options;\n      const localId = mapLocalId.get(trackId);\n      const transceiver = this._pc.getTransceivers().find(t => t.mid === localId);\n      if (!transceiver) {\n        throw new Error('new RTCRtpTransceiver not found');\n      }\n      // Store in the map.\n      this._mapMidTransceiver.set(localId, transceiver);\n      results.push({\n        localId,\n        track: transceiver.receiver.track,\n        rtpReceiver: transceiver.receiver\n      });\n    }\n    return results;\n  }\n  async stopReceiving(localIds) {\n    this.assertRecvDirection();\n    if (this._closed) {\n      return;\n    }\n    for (const localId of localIds) {\n      logger.debug('stopReceiving() [localId:%s]', localId);\n      const transceiver = this._mapMidTransceiver.get(localId);\n      if (!transceiver) {\n        throw new Error('associated RTCRtpTransceiver not found');\n      }\n      this._remoteSdp.closeMediaSection(transceiver.mid);\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    const answer = await this._pc.createAnswer();\n    logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n    for (const localId of localIds) {\n      this._mapMidTransceiver.delete(localId);\n    }\n  }\n  async pauseReceiving(localIds) {\n    this.assertNotClosed();\n    this.assertRecvDirection();\n    for (const localId of localIds) {\n      logger.debug('pauseReceiving() [localId:%s]', localId);\n      const transceiver = this._mapMidTransceiver.get(localId);\n      if (!transceiver) {\n        throw new Error('associated RTCRtpTransceiver not found');\n      }\n      transceiver.direction = 'inactive';\n      this._remoteSdp.pauseMediaSection(localId);\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    const answer = await this._pc.createAnswer();\n    logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n  }\n  async resumeReceiving(localIds) {\n    this.assertNotClosed();\n    this.assertRecvDirection();\n    for (const localId of localIds) {\n      logger.debug('resumeReceiving() [localId:%s]', localId);\n      const transceiver = this._mapMidTransceiver.get(localId);\n      if (!transceiver) {\n        throw new Error('associated RTCRtpTransceiver not found');\n      }\n      transceiver.direction = 'recvonly';\n      this._remoteSdp.resumeReceivingMediaSection(localId);\n    }\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    const answer = await this._pc.createAnswer();\n    logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n  }\n  async getReceiverStats(localId) {\n    this.assertRecvDirection();\n    const transceiver = this._mapMidTransceiver.get(localId);\n    if (!transceiver) {\n      throw new Error('associated RTCRtpTransceiver not found');\n    }\n    return transceiver.receiver.getStats();\n  }\n  async receiveDataChannel({\n    sctpStreamParameters,\n    label,\n    protocol\n  }) {\n    this.assertNotClosed();\n    this.assertRecvDirection();\n    const {\n      streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits\n    } = sctpStreamParameters;\n    const options = {\n      negotiated: true,\n      id: streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('receiveDataChannel() [options:%o]', options);\n    const dataChannel = this._pc.createDataChannel(label, options);\n    // If this is the first DataChannel we need to create the SDP offer with\n    // m=application section.\n    if (!this._hasDataChannelMediaSection) {\n      this._remoteSdp.receiveSctpAssociation();\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      if (!this._transportReady) {\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        await this.setupTransport({\n          localDtlsRole: 'client',\n          localSdpObject\n        });\n      }\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n    return {\n      dataChannel\n    };\n  }\n  async setupTransport({\n    localDtlsRole,\n    localSdpObject\n  }) {\n    if (!localSdpObject) {\n      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    }\n    // Get our local DTLS parameters.\n    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n      sdpObject: localSdpObject\n    });\n    // Set our DTLS role.\n    dtlsParameters.role = localDtlsRole;\n    // Update the remote DTLS role in the SDP.\n    this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n    // Need to tell the remote transport about our parameters.\n    await new Promise((resolve, reject) => {\n      this.safeEmit('@connect', {\n        dtlsParameters\n      }, resolve, reject);\n    });\n    this._transportReady = true;\n  }\n  assertNotClosed() {\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('method called in a closed handler');\n    }\n  }\n  assertSendDirection() {\n    if (this._direction !== 'send') {\n      throw new Error('method can just be called for handlers with \"send\" direction');\n    }\n  }\n  assertRecvDirection() {\n    if (this._direction !== 'recv') {\n      throw new Error('method can just be called for handlers with \"recv\" direction');\n    }\n  }\n}\nexports.Firefox120 = Firefox120;","map":{"version":3,"names":["Object","defineProperty","exports","value","Firefox120","sdpTransform","require","Logger_1","errors_1","utils","ortc","sdpCommonUtils","sdpUnifiedPlanUtils","HandlerInterface_1","RemoteSdp_1","scalabilityModes_1","logger","Logger","NAME","SCTP_NUM_STREAMS","OS","MIS","HandlerInterface","_closed","_direction","_remoteSdp","_sendingRtpParametersByKind","_sendingRemoteRtpParametersByKind","_pc","_mapMidTransceiver","Map","_sendStream","MediaStream","_hasDataChannelMediaSection","_nextSendSctpStreamId","_transportReady","createFactory","constructor","name","close","debug","error","emit","getNativeRtpCapabilities","pc","RTCPeerConnection","iceServers","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","canvas","document","createElement","getContext","fakeStream","captureStream","fakeVideoTrack","getVideoTracks","addTransceiver","direction","sendEncodings","rid","maxBitrate","offer","createOffer","remove","stop","sdpObject","parse","sdp","nativeRtpCapabilities","extractRtpCapabilities","error2","getNativeSctpCapabilities","numStreams","run","iceParameters","iceCandidates","dtlsParameters","sctpParameters","additionalSettings","proprietaryConstraints","extendedRtpCapabilities","assertNotClosed","RemoteSdp","audio","getSendingRtpParameters","video","getSendingRemoteRtpParameters","addEventListener","iceGatheringState","event","connectionState","warn","iceConnectionState","updateIceServers","UnsupportedError","restartIce","updateIceParameters","iceRestart","setLocalDescription","answer","type","getSdp","setRemoteDescription","createAnswer","getTransportStats","getStats","send","track","encodings","codecOptions","codec","onRtpSender","assertSendDirection","kind","id","length","forEach","encoding","idx","sendingRtpParameters","clone","codecs","reduceCodecs","sendingRemoteRtpParameters","transceiver","streams","sender","localSdpObject","extmapAllowMixed","setSessionExtmapAllowMixed","setupTransport","localDtlsRole","layers","scalabilityMode","localId","mid","localDescription","offerMediaObject","media","rtcp","cname","getCname","getRtpEncodings","newEncodings","assign","mimeType","toLowerCase","temporalLayers","offerRtpParameters","answerRtpParameters","set","rtpParameters","rtpSender","stopSending","get","Error","replaceTrack","removeTrack","disableMediaSection","delete","pauseSending","pauseMediaSection","resumeSending","resumeSendingMediaSection","setMaxSpatialLayer","spatialLayer","parameters","getParameters","active","setParameters","muxMediaSectionSimulcast","setRtpEncodingParameters","params","getSenderStats","sendDataChannel","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","options","negotiated","dataChannel","createDataChannel","find","m","sendSctpAssociation","sctpStreamParameters","streamId","receive","optionsList","assertRecvDirection","results","mapLocalId","trackId","String","size","onRtpReceiver","getTransceivers","t","receiver","answerMediaObject","applyCodecParameters","write","push","rtpReceiver","stopReceiving","localIds","closeMediaSection","pauseReceiving","resumeReceiving","resumeReceivingMediaSection","getReceiverStats","receiveDataChannel","receiveSctpAssociation","extractDtlsParameters","role","updateDtlsRole","Promise","resolve","reject","safeEmit","InvalidStateError"],"sources":["/Users/user/turn/turn-front/node_modules/mediasoup-client/lib/handlers/Firefox120.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Firefox120 = void 0;\nconst sdpTransform = require(\"sdp-transform\");\nconst Logger_1 = require(\"../Logger\");\nconst errors_1 = require(\"../errors\");\nconst utils = require(\"../utils\");\nconst ortc = require(\"../ortc\");\nconst sdpCommonUtils = require(\"./sdp/commonUtils\");\nconst sdpUnifiedPlanUtils = require(\"./sdp/unifiedPlanUtils\");\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst scalabilityModes_1 = require(\"../scalabilityModes\");\nconst logger = new Logger_1.Logger('Firefox120');\nconst NAME = 'Firefox120';\nconst SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };\nclass Firefox120 extends HandlerInterface_1.HandlerInterface {\n    // Closed flag.\n    _closed = false;\n    // Handler direction.\n    _direction;\n    // Remote SDP handler.\n    _remoteSdp;\n    // Generic sending RTP parameters for audio and video.\n    _sendingRtpParametersByKind;\n    // Generic sending RTP parameters for audio and video suitable for the SDP\n    // remote answer.\n    _sendingRemoteRtpParametersByKind;\n    // RTCPeerConnection instance.\n    _pc;\n    // Map of RTCTransceivers indexed by MID.\n    _mapMidTransceiver = new Map();\n    // Local stream for sending.\n    _sendStream = new MediaStream();\n    // Whether a DataChannel m=application section has been created.\n    _hasDataChannelMediaSection = false;\n    // Sending DataChannel id value counter. Incremented for each new DataChannel.\n    _nextSendSctpStreamId = 0;\n    // Got transport local and remote parameters.\n    _transportReady = false;\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Firefox120();\n    }\n    constructor() {\n        super();\n    }\n    get name() {\n        return NAME;\n    }\n    close() {\n        logger.debug('close()');\n        if (this._closed) {\n            return;\n        }\n        this._closed = true;\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n        });\n        // NOTE: We need to add a real video track to get the RID extension mapping,\n        // otherwiser Firefox doesn't include it in the SDP.\n        const canvas = document.createElement('canvas');\n        // NOTE: Otherwise Firefox fails in next line.\n        canvas.getContext('2d');\n        const fakeStream = canvas.captureStream();\n        const fakeVideoTrack = fakeStream.getVideoTracks()[0];\n        try {\n            pc.addTransceiver('audio', { direction: 'sendrecv' });\n            pc.addTransceiver(fakeVideoTrack, {\n                direction: 'sendrecv',\n                sendEncodings: [\n                    { rid: 'r0', maxBitrate: 100000 },\n                    { rid: 'r1', maxBitrate: 500000 },\n                ],\n            });\n            const offer = await pc.createOffer();\n            try {\n                canvas.remove();\n            }\n            catch (error) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error) { }\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                canvas.remove();\n            }\n            catch (error2) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error2) { }\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        this.assertNotClosed();\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers ?? [],\n            iceTransportPolicy: iceTransportPolicy ?? 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        this._pc.addEventListener('icecandidateerror', (event) => {\n            this.emit('@icecandidateerror', event);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateIceServers(iceServers) {\n        this.assertNotClosed();\n        // NOTE: Firefox does not implement pc.setConfiguration().\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    async restartIce(iceParameters) {\n        this.assertNotClosed();\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        this.assertNotClosed();\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (encodings && encodings.length > 1) {\n            encodings.forEach((encoding, idx) => {\n                encoding.rid = `r${idx}`;\n            });\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        // NOTE: Firefox fails sometimes to properly anticipate the closed media\n        // section that it should use, so don't reuse closed media sections.\n        //   https://github.com/versatica/mediasoup-client/issues/104\n        //\n        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n            sendEncodings: encodings,\n        });\n        if (onRtpSender) {\n            onRtpSender(transceiver.sender);\n        }\n        const offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        // @ts-expect-error --- sdpTransform.SessionDescription type doesn't\n        // define extmapAllowMixed field.\n        if (localSdpObject.extmapAllowMixed) {\n            this._remoteSdp.setSessionExtmapAllowMixed();\n        }\n        // In Firefox use DTLS role client even if we are the \"offerer\" since\n        // Firefox does not respect ICE-Lite.\n        if (!this._transportReady) {\n            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n        }\n        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n            Object.assign(newEncodings[0], encodings[0]);\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim.\n        else {\n            sendingRtpParameters.encodings = encodings;\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                if (encoding.scalabilityMode) {\n                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;\n                }\n                else {\n                    encoding.scalabilityMode = 'L1T3';\n                }\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        if (this._closed) {\n            return;\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated transceiver not found');\n        }\n        void transceiver.sender.replaceTrack(null);\n        // NOTE: Cannot use stop() the transceiver due to the the note above in\n        // send() method.\n        // try\n        // {\n        // \ttransceiver.stop();\n        // }\n        // catch (error)\n        // {}\n        this._pc.removeTrack(transceiver.sender);\n        // NOTE: Cannot use closeMediaSection() due to the the note above in send()\n        // method.\n        // this._remoteSdp!.closeMediaSection(transceiver.mid);\n        this._remoteSdp.disableMediaSection(transceiver.mid);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        this._mapMidTransceiver.delete(localId);\n    }\n    async pauseSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('pauseSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'inactive';\n        this._remoteSdp.pauseMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async resumeSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('resumeSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'sendonly';\n        this._remoteSdp.resumeSendingMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated transceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async getSenderStats(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const results = [];\n        const mapLocalId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);\n            mapLocalId.set(trackId, localId);\n            this._remoteSdp.receive({\n                mid: localId,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId ?? rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        for (const options of optionsList) {\n            const { trackId, onRtpReceiver } = options;\n            if (onRtpReceiver) {\n                const localId = mapLocalId.get(trackId);\n                const transceiver = this._pc\n                    .getTransceivers()\n                    .find((t) => t.mid === localId);\n                if (!transceiver) {\n                    throw new Error('transceiver not found');\n                }\n                onRtpReceiver(transceiver.receiver);\n            }\n        }\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { trackId, rtpParameters } = options;\n            const localId = mapLocalId.get(trackId);\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        if (!this._transportReady) {\n            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { trackId } = options;\n            const localId = mapLocalId.get(trackId);\n            const transceiver = this._pc\n                .getTransceivers()\n                .find((t) => t.mid === localId);\n            if (!transceiver) {\n                throw new Error('new RTCRtpTransceiver not found');\n            }\n            // Store in the map.\n            this._mapMidTransceiver.set(localId, transceiver);\n            results.push({\n                localId,\n                track: transceiver.receiver.track,\n                rtpReceiver: transceiver.receiver,\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        if (this._closed) {\n            return;\n        }\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            this._remoteSdp.closeMediaSection(transceiver.mid);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const localId of localIds) {\n            this._mapMidTransceiver.delete(localId);\n        }\n    }\n    async pauseReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('pauseReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'inactive';\n            this._remoteSdp.pauseMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async resumeReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('resumeReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'recvonly';\n            this._remoteSdp.resumeReceivingMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertNotClosed() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('method called in a closed handler');\n        }\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Firefox120 = Firefox120;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}