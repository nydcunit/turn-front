{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transport = void 0;\nconst awaitqueue_1 = require(\"awaitqueue\");\nconst Logger_1 = require(\"./Logger\");\nconst enhancedEvents_1 = require(\"./enhancedEvents\");\nconst errors_1 = require(\"./errors\");\nconst utils = require(\"./utils\");\nconst ortc = require(\"./ortc\");\nconst Producer_1 = require(\"./Producer\");\nconst Consumer_1 = require(\"./Consumer\");\nconst DataProducer_1 = require(\"./DataProducer\");\nconst DataConsumer_1 = require(\"./DataConsumer\");\nconst logger = new Logger_1.Logger('Transport');\nclass ConsumerCreationTask {\n  consumerOptions;\n  promise;\n  resolve;\n  reject;\n  constructor(consumerOptions) {\n    this.consumerOptions = consumerOptions;\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\nclass Transport extends enhancedEvents_1.EnhancedEventEmitter {\n  // Id.\n  _id;\n  // Closed flag.\n  _closed = false;\n  // Direction.\n  _direction;\n  // Extended RTP capabilities.\n  _extendedRtpCapabilities;\n  // Whether we can produce audio/video based on computed extended RTP\n  // capabilities.\n  _canProduceByKind;\n  // SCTP max message size if enabled, null otherwise.\n  _maxSctpMessageSize;\n  // RTC handler isntance.\n  _handler;\n  // Transport ICE gathering state.\n  _iceGatheringState = 'new';\n  // Transport connection state.\n  _connectionState = 'new';\n  // App custom data.\n  _appData;\n  // Map of Producers indexed by id.\n  _producers = new Map();\n  // Map of Consumers indexed by id.\n  _consumers = new Map();\n  // Map of DataProducers indexed by id.\n  _dataProducers = new Map();\n  // Map of DataConsumers indexed by id.\n  _dataConsumers = new Map();\n  // Whether the Consumer for RTP probation has been created.\n  _probatorConsumerCreated = false;\n  // AwaitQueue instance to make async tasks happen sequentially.\n  _awaitQueue = new awaitqueue_1.AwaitQueue();\n  // Consumer creation tasks awaiting to be processed.\n  _pendingConsumerTasks = [];\n  // Consumer creation in progress flag.\n  _consumerCreationInProgress = false;\n  // Consumers pending to be paused.\n  _pendingPauseConsumers = new Map();\n  // Consumer pause in progress flag.\n  _consumerPauseInProgress = false;\n  // Consumers pending to be resumed.\n  _pendingResumeConsumers = new Map();\n  // Consumer resume in progress flag.\n  _consumerResumeInProgress = false;\n  // Consumers pending to be closed.\n  _pendingCloseConsumers = new Map();\n  // Consumer close in progress flag.\n  _consumerCloseInProgress = false;\n  // Observer instance.\n  _observer = new enhancedEvents_1.EnhancedEventEmitter();\n  constructor({\n    direction,\n    id,\n    iceParameters,\n    iceCandidates,\n    dtlsParameters,\n    sctpParameters,\n    iceServers,\n    iceTransportPolicy,\n    additionalSettings,\n    proprietaryConstraints,\n    appData,\n    handlerFactory,\n    extendedRtpCapabilities,\n    canProduceByKind\n  }) {\n    super();\n    logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n    this._id = id;\n    this._direction = direction;\n    this._extendedRtpCapabilities = extendedRtpCapabilities;\n    this._canProduceByKind = canProduceByKind;\n    this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;\n    // Clone and sanitize additionalSettings.\n    const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};\n    delete clonedAdditionalSettings.iceServers;\n    delete clonedAdditionalSettings.iceTransportPolicy;\n    delete clonedAdditionalSettings.bundlePolicy;\n    delete clonedAdditionalSettings.rtcpMuxPolicy;\n    delete clonedAdditionalSettings.sdpSemantics;\n    this._handler = handlerFactory();\n    this._handler.run({\n      direction,\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      iceServers,\n      iceTransportPolicy,\n      additionalSettings: clonedAdditionalSettings,\n      proprietaryConstraints,\n      extendedRtpCapabilities\n    });\n    this._appData = appData ?? {};\n    this.handleHandler();\n  }\n  /**\n   * Transport id.\n   */\n  get id() {\n    return this._id;\n  }\n  /**\n   * Whether the Transport is closed.\n   */\n  get closed() {\n    return this._closed;\n  }\n  /**\n   * Transport direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  /**\n   * RTC handler instance.\n   */\n  get handler() {\n    return this._handler;\n  }\n  /**\n   * ICE gathering state.\n   */\n  get iceGatheringState() {\n    return this._iceGatheringState;\n  }\n  /**\n   * Connection state.\n   */\n  get connectionState() {\n    return this._connectionState;\n  }\n  /**\n   * App custom data.\n   */\n  get appData() {\n    return this._appData;\n  }\n  /**\n   * App custom data setter.\n   */\n  set appData(appData) {\n    this._appData = appData;\n  }\n  get observer() {\n    return this._observer;\n  }\n  /**\n   * Close the Transport.\n   */\n  close() {\n    if (this._closed) {\n      return;\n    }\n    logger.debug('close()');\n    this._closed = true;\n    // Stop the AwaitQueue.\n    this._awaitQueue.stop();\n    // Close the handler.\n    this._handler.close();\n    // Change connection state to 'closed' since the handler may not emit\n    // '@connectionstatechange' event.\n    this._connectionState = 'closed';\n    // Close all Producers.\n    for (const producer of this._producers.values()) {\n      producer.transportClosed();\n    }\n    this._producers.clear();\n    // Close all Consumers.\n    for (const consumer of this._consumers.values()) {\n      consumer.transportClosed();\n    }\n    this._consumers.clear();\n    // Close all DataProducers.\n    for (const dataProducer of this._dataProducers.values()) {\n      dataProducer.transportClosed();\n    }\n    this._dataProducers.clear();\n    // Close all DataConsumers.\n    for (const dataConsumer of this._dataConsumers.values()) {\n      dataConsumer.transportClosed();\n    }\n    this._dataConsumers.clear();\n    // Emit observer event.\n    this._observer.safeEmit('close');\n  }\n  /**\n   * Get associated Transport (RTCPeerConnection) stats.\n   *\n   * @returns {RTCStatsReport}\n   */\n  async getStats() {\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    }\n    return this._handler.getTransportStats();\n  }\n  /**\n   * Restart ICE connection.\n   */\n  async restartIce({\n    iceParameters\n  }) {\n    logger.debug('restartIce()');\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (!iceParameters) {\n      throw new TypeError('missing iceParameters');\n    }\n    // Enqueue command.\n    return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), 'transport.restartIce()');\n  }\n  /**\n   * Update ICE servers.\n   */\n  async updateIceServers({\n    iceServers\n  } = {}) {\n    logger.debug('updateIceServers()');\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (!Array.isArray(iceServers)) {\n      throw new TypeError('missing iceServers');\n    }\n    // Enqueue command.\n    return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');\n  }\n  /**\n   * Create a Producer.\n   */\n  async produce({\n    track,\n    encodings,\n    codecOptions,\n    codec,\n    stopTracks = true,\n    disableTrackOnPause = true,\n    zeroRtpOnPause = false,\n    onRtpSender,\n    appData = {}\n  } = {}) {\n    logger.debug('produce() [track:%o]', track);\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (!track) {\n      throw new TypeError('missing track');\n    } else if (this._direction !== 'send') {\n      throw new errors_1.UnsupportedError('not a sending Transport');\n    } else if (!this._canProduceByKind[track.kind]) {\n      throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\n    } else if (track.readyState === 'ended') {\n      throw new errors_1.InvalidStateError('track ended');\n    } else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') {\n      throw new TypeError('no \"connect\" listener set into this transport');\n    } else if (this.listenerCount('produce') === 0) {\n      throw new TypeError('no \"produce\" listener set into this transport');\n    } else if (appData && typeof appData !== 'object') {\n      throw new TypeError('if given, appData must be an object');\n    }\n    // Enqueue command.\n    return this._awaitQueue.push(async () => {\n      let normalizedEncodings;\n      if (encodings && !Array.isArray(encodings)) {\n        throw TypeError('encodings must be an array');\n      } else if (encodings && encodings.length === 0) {\n        normalizedEncodings = undefined;\n      } else if (encodings) {\n        normalizedEncodings = encodings.map(encoding => {\n          const normalizedEncoding = {\n            active: true\n          };\n          if (encoding.active === false) {\n            normalizedEncoding.active = false;\n          }\n          if (typeof encoding.dtx === 'boolean') {\n            normalizedEncoding.dtx = encoding.dtx;\n          }\n          if (typeof encoding.scalabilityMode === 'string') {\n            normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n          }\n          if (typeof encoding.scaleResolutionDownBy === 'number') {\n            normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\n          }\n          if (typeof encoding.maxBitrate === 'number') {\n            normalizedEncoding.maxBitrate = encoding.maxBitrate;\n          }\n          if (typeof encoding.maxFramerate === 'number') {\n            normalizedEncoding.maxFramerate = encoding.maxFramerate;\n          }\n          if (typeof encoding.adaptivePtime === 'boolean') {\n            normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n          }\n          if (typeof encoding.priority === 'string') {\n            normalizedEncoding.priority = encoding.priority;\n          }\n          if (typeof encoding.networkPriority === 'string') {\n            normalizedEncoding.networkPriority = encoding.networkPriority;\n          }\n          return normalizedEncoding;\n        });\n      }\n      const {\n        localId,\n        rtpParameters,\n        rtpSender\n      } = await this._handler.send({\n        track,\n        encodings: normalizedEncodings,\n        codecOptions,\n        codec,\n        onRtpSender\n      });\n      try {\n        // This will fill rtpParameters's missing fields with default values.\n        ortc.validateRtpParameters(rtpParameters);\n        const {\n          id\n        } = await new Promise((resolve, reject) => {\n          this.safeEmit('produce', {\n            kind: track.kind,\n            rtpParameters,\n            appData\n          }, resolve, reject);\n        });\n        const producer = new Producer_1.Producer({\n          id,\n          localId,\n          rtpSender,\n          track,\n          rtpParameters,\n          stopTracks,\n          disableTrackOnPause,\n          zeroRtpOnPause,\n          appData\n        });\n        this._producers.set(producer.id, producer);\n        this.handleProducer(producer);\n        // Emit observer event.\n        this._observer.safeEmit('newproducer', producer);\n        return producer;\n      } catch (error) {\n        this._handler.stopSending(localId).catch(() => {});\n        throw error;\n      }\n    }, 'transport.produce()')\n    // This catch is needed to stop the given track if the command above\n    // failed due to closed Transport.\n    .catch(error => {\n      if (stopTracks) {\n        try {\n          track.stop();\n        } catch (error2) {}\n      }\n      throw error;\n    });\n  }\n  /**\n   * Create a Consumer to consume a remote Producer.\n   */\n  async consume({\n    id,\n    producerId,\n    kind,\n    rtpParameters,\n    streamId,\n    onRtpReceiver,\n    appData = {}\n  }) {\n    logger.debug('consume()');\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (this._direction !== 'recv') {\n      throw new errors_1.UnsupportedError('not a receiving Transport');\n    } else if (typeof id !== 'string') {\n      throw new TypeError('missing id');\n    } else if (typeof producerId !== 'string') {\n      throw new TypeError('missing producerId');\n    } else if (kind !== 'audio' && kind !== 'video') {\n      throw new TypeError(`invalid kind '${kind}'`);\n    } else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') {\n      throw new TypeError('no \"connect\" listener set into this transport');\n    } else if (appData && typeof appData !== 'object') {\n      throw new TypeError('if given, appData must be an object');\n    }\n    // Clone given RTP parameters to not modify input data.\n    const clonedRtpParameters = utils.clone(rtpParameters);\n    // Ensure the device can consume it.\n    const canConsume = ortc.canReceive(clonedRtpParameters, this._extendedRtpCapabilities);\n    if (!canConsume) {\n      throw new errors_1.UnsupportedError('cannot consume this Producer');\n    }\n    const consumerCreationTask = new ConsumerCreationTask({\n      id,\n      producerId,\n      kind,\n      rtpParameters: clonedRtpParameters,\n      streamId,\n      onRtpReceiver,\n      appData\n    });\n    // Store the Consumer creation task.\n    this._pendingConsumerTasks.push(consumerCreationTask);\n    // There is no Consumer creation in progress, create it now.\n    queueMicrotask(() => {\n      if (this._closed) {\n        return;\n      }\n      if (this._consumerCreationInProgress === false) {\n        this.createPendingConsumers();\n      }\n    });\n    return consumerCreationTask.promise;\n  }\n  /**\n   * Create a DataProducer\n   */\n  async produceData({\n    ordered = true,\n    maxPacketLifeTime,\n    maxRetransmits,\n    label = '',\n    protocol = '',\n    appData = {}\n  } = {}) {\n    logger.debug('produceData()');\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (this._direction !== 'send') {\n      throw new errors_1.UnsupportedError('not a sending Transport');\n    } else if (!this._maxSctpMessageSize) {\n      throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n    } else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') {\n      throw new TypeError('no \"connect\" listener set into this transport');\n    } else if (this.listenerCount('producedata') === 0) {\n      throw new TypeError('no \"producedata\" listener set into this transport');\n    } else if (appData && typeof appData !== 'object') {\n      throw new TypeError('if given, appData must be an object');\n    }\n    if (maxPacketLifeTime || maxRetransmits) {\n      ordered = false;\n    }\n    // Enqueue command.\n    return this._awaitQueue.push(async () => {\n      const {\n        dataChannel,\n        sctpStreamParameters\n      } = await this._handler.sendDataChannel({\n        ordered,\n        maxPacketLifeTime,\n        maxRetransmits,\n        label,\n        protocol\n      });\n      // This will fill sctpStreamParameters's missing fields with default values.\n      ortc.validateSctpStreamParameters(sctpStreamParameters);\n      const {\n        id\n      } = await new Promise((resolve, reject) => {\n        this.safeEmit('producedata', {\n          sctpStreamParameters,\n          label,\n          protocol,\n          appData\n        }, resolve, reject);\n      });\n      const dataProducer = new DataProducer_1.DataProducer({\n        id,\n        dataChannel,\n        sctpStreamParameters,\n        appData\n      });\n      this._dataProducers.set(dataProducer.id, dataProducer);\n      this.handleDataProducer(dataProducer);\n      // Emit observer event.\n      this._observer.safeEmit('newdataproducer', dataProducer);\n      return dataProducer;\n    }, 'transport.produceData()');\n  }\n  /**\n   * Create a DataConsumer\n   */\n  async consumeData({\n    id,\n    dataProducerId,\n    sctpStreamParameters,\n    label = '',\n    protocol = '',\n    appData = {}\n  }) {\n    logger.debug('consumeData()');\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (this._direction !== 'recv') {\n      throw new errors_1.UnsupportedError('not a receiving Transport');\n    } else if (!this._maxSctpMessageSize) {\n      throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n    } else if (typeof id !== 'string') {\n      throw new TypeError('missing id');\n    } else if (typeof dataProducerId !== 'string') {\n      throw new TypeError('missing dataProducerId');\n    } else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') {\n      throw new TypeError('no \"connect\" listener set into this transport');\n    } else if (appData && typeof appData !== 'object') {\n      throw new TypeError('if given, appData must be an object');\n    }\n    // Clone given SCTP stream parameters to not modify input data.\n    const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);\n    // This may throw.\n    ortc.validateSctpStreamParameters(clonedSctpStreamParameters);\n    // Enqueue command.\n    return this._awaitQueue.push(async () => {\n      const {\n        dataChannel\n      } = await this._handler.receiveDataChannel({\n        sctpStreamParameters: clonedSctpStreamParameters,\n        label,\n        protocol\n      });\n      const dataConsumer = new DataConsumer_1.DataConsumer({\n        id,\n        dataProducerId,\n        dataChannel,\n        sctpStreamParameters: clonedSctpStreamParameters,\n        appData\n      });\n      this._dataConsumers.set(dataConsumer.id, dataConsumer);\n      this.handleDataConsumer(dataConsumer);\n      // Emit observer event.\n      this._observer.safeEmit('newdataconsumer', dataConsumer);\n      return dataConsumer;\n    }, 'transport.consumeData()');\n  }\n  // This method is guaranteed to never throw.\n  createPendingConsumers() {\n    this._consumerCreationInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingConsumerTasks.length === 0) {\n        logger.debug('createPendingConsumers() | there is no Consumer to be created');\n        return;\n      }\n      const pendingConsumerTasks = [...this._pendingConsumerTasks];\n      // Clear pending Consumer tasks.\n      this._pendingConsumerTasks = [];\n      // Video Consumer in order to create the probator.\n      let videoConsumerForProbator = undefined;\n      // Fill options list.\n      const optionsList = [];\n      for (const task of pendingConsumerTasks) {\n        const {\n          id,\n          kind,\n          rtpParameters,\n          streamId,\n          onRtpReceiver\n        } = task.consumerOptions;\n        optionsList.push({\n          trackId: id,\n          kind: kind,\n          rtpParameters,\n          streamId,\n          onRtpReceiver\n        });\n      }\n      try {\n        const results = await this._handler.receive(optionsList);\n        for (let idx = 0; idx < results.length; ++idx) {\n          const task = pendingConsumerTasks[idx];\n          const result = results[idx];\n          const {\n            id,\n            producerId,\n            kind,\n            rtpParameters,\n            appData\n          } = task.consumerOptions;\n          const {\n            localId,\n            rtpReceiver,\n            track\n          } = result;\n          const consumer = new Consumer_1.Consumer({\n            id: id,\n            localId,\n            producerId: producerId,\n            rtpReceiver,\n            track,\n            rtpParameters,\n            appData: appData\n          });\n          this._consumers.set(consumer.id, consumer);\n          this.handleConsumer(consumer);\n          // If this is the first video Consumer and the Consumer for RTP probation\n          // has not yet been created, it's time to create it.\n          if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === 'video') {\n            videoConsumerForProbator = consumer;\n          }\n          // Emit observer event.\n          this._observer.safeEmit('newconsumer', consumer);\n          task.resolve(consumer);\n        }\n      } catch (error) {\n        for (const task of pendingConsumerTasks) {\n          task.reject(error);\n        }\n      }\n      // If RTP probation must be handled, do it now.\n      if (videoConsumerForProbator) {\n        try {\n          const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);\n          await this._handler.receive([{\n            trackId: 'probator',\n            kind: 'video',\n            rtpParameters: probatorRtpParameters\n          }]);\n          logger.debug('createPendingConsumers() | Consumer for RTP probation created');\n          this._probatorConsumerCreated = true;\n        } catch (error) {\n          logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);\n        }\n      }\n    }, 'transport.createPendingConsumers()').then(() => {\n      this._consumerCreationInProgress = false;\n      // There are pending Consumer tasks, enqueue their creation.\n      if (this._pendingConsumerTasks.length > 0) {\n        this.createPendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  pausePendingConsumers() {\n    this._consumerPauseInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingPauseConsumers.size === 0) {\n        logger.debug('pausePendingConsumers() | there is no Consumer to be paused');\n        return;\n      }\n      const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());\n      // Clear pending pause Consumer map.\n      this._pendingPauseConsumers.clear();\n      try {\n        const localIds = pendingPauseConsumers.map(consumer => consumer.localId);\n        await this._handler.pauseReceiving(localIds);\n      } catch (error) {\n        logger.error('pausePendingConsumers() | failed to pause Consumers:', error);\n      }\n    }, 'transport.pausePendingConsumers').then(() => {\n      this._consumerPauseInProgress = false;\n      // There are pending Consumers to be paused, do it.\n      if (this._pendingPauseConsumers.size > 0) {\n        this.pausePendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  resumePendingConsumers() {\n    this._consumerResumeInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingResumeConsumers.size === 0) {\n        logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');\n        return;\n      }\n      const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());\n      // Clear pending resume Consumer map.\n      this._pendingResumeConsumers.clear();\n      try {\n        const localIds = pendingResumeConsumers.map(consumer => consumer.localId);\n        await this._handler.resumeReceiving(localIds);\n      } catch (error) {\n        logger.error('resumePendingConsumers() | failed to resume Consumers:', error);\n      }\n    }, 'transport.resumePendingConsumers').then(() => {\n      this._consumerResumeInProgress = false;\n      // There are pending Consumer to be resumed, do it.\n      if (this._pendingResumeConsumers.size > 0) {\n        this.resumePendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  closePendingConsumers() {\n    this._consumerCloseInProgress = true;\n    this._awaitQueue.push(async () => {\n      if (this._pendingCloseConsumers.size === 0) {\n        logger.debug('closePendingConsumers() | there is no Consumer to be closed');\n        return;\n      }\n      const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());\n      // Clear pending close Consumer map.\n      this._pendingCloseConsumers.clear();\n      try {\n        await this._handler.stopReceiving(pendingCloseConsumers.map(consumer => consumer.localId));\n      } catch (error) {\n        logger.error('closePendingConsumers() | failed to close Consumers:', error);\n      }\n    }, 'transport.closePendingConsumers').then(() => {\n      this._consumerCloseInProgress = false;\n      // There are pending Consumer to be resumed, do it.\n      if (this._pendingCloseConsumers.size > 0) {\n        this.closePendingConsumers();\n      }\n    })\n    // NOTE: We only get here when the await queue is closed.\n    .catch(() => {});\n  }\n  handleHandler() {\n    const handler = this._handler;\n    handler.on('@connect', ({\n      dtlsParameters\n    }, callback, errback) => {\n      if (this._closed) {\n        errback(new errors_1.InvalidStateError('closed'));\n        return;\n      }\n      this.safeEmit('connect', {\n        dtlsParameters\n      }, callback, errback);\n    });\n    handler.on('@icegatheringstatechange', iceGatheringState => {\n      if (iceGatheringState === this._iceGatheringState) {\n        return;\n      }\n      logger.debug('ICE gathering state changed to %s', iceGatheringState);\n      this._iceGatheringState = iceGatheringState;\n      if (!this._closed) {\n        this.safeEmit('icegatheringstatechange', iceGatheringState);\n      }\n    });\n    handler.on('@icecandidateerror', event => {\n      logger.warn(`ICE candidate error [url:${event.url}, localAddress:${event.address}, localPort:${event.port}]: ${event.errorCode} \"${event.errorText}\"`);\n      this.safeEmit('icecandidateerror', event);\n    });\n    handler.on('@connectionstatechange', connectionState => {\n      if (connectionState === this._connectionState) {\n        return;\n      }\n      logger.debug('connection state changed to %s', connectionState);\n      this._connectionState = connectionState;\n      if (!this._closed) {\n        this.safeEmit('connectionstatechange', connectionState);\n      }\n    });\n  }\n  handleProducer(producer) {\n    producer.on('@close', () => {\n      this._producers.delete(producer.id);\n      if (this._closed) {\n        return;\n      }\n      this._awaitQueue.push(async () => await this._handler.stopSending(producer.localId), 'producer @close event').catch(error => logger.warn('producer.close() failed:%o', error));\n    });\n    producer.on('@pause', (callback, errback) => {\n      this._awaitQueue.push(async () => await this._handler.pauseSending(producer.localId), 'producer @pause event').then(callback).catch(errback);\n    });\n    producer.on('@resume', (callback, errback) => {\n      this._awaitQueue.push(async () => await this._handler.resumeSending(producer.localId), 'producer @resume event').then(callback).catch(errback);\n    });\n    producer.on('@replacetrack', (track, callback, errback) => {\n      this._awaitQueue.push(async () => await this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event').then(callback).catch(errback);\n    });\n    producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n      this._awaitQueue.push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event').then(callback).catch(errback);\n    });\n    producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n      this._awaitQueue.push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event').then(callback).catch(errback);\n    });\n    producer.on('@getstats', (callback, errback) => {\n      if (this._closed) {\n        return errback(new errors_1.InvalidStateError('closed'));\n      }\n      this._handler.getSenderStats(producer.localId).then(callback).catch(errback);\n    });\n  }\n  handleConsumer(consumer) {\n    consumer.on('@close', () => {\n      this._consumers.delete(consumer.id);\n      this._pendingPauseConsumers.delete(consumer.id);\n      this._pendingResumeConsumers.delete(consumer.id);\n      if (this._closed) {\n        return;\n      }\n      // Store the Consumer into the close list.\n      this._pendingCloseConsumers.set(consumer.id, consumer);\n      // There is no Consumer close in progress, do it now.\n      if (this._consumerCloseInProgress === false) {\n        this.closePendingConsumers();\n      }\n    });\n    consumer.on('@pause', () => {\n      // If Consumer is pending to be resumed, remove from pending resume list.\n      if (this._pendingResumeConsumers.has(consumer.id)) {\n        this._pendingResumeConsumers.delete(consumer.id);\n      }\n      // Store the Consumer into the pending list.\n      this._pendingPauseConsumers.set(consumer.id, consumer);\n      // There is no Consumer pause in progress, do it now.\n      queueMicrotask(() => {\n        if (this._closed) {\n          return;\n        }\n        if (this._consumerPauseInProgress === false) {\n          this.pausePendingConsumers();\n        }\n      });\n    });\n    consumer.on('@resume', () => {\n      // If Consumer is pending to be paused, remove from pending pause list.\n      if (this._pendingPauseConsumers.has(consumer.id)) {\n        this._pendingPauseConsumers.delete(consumer.id);\n      }\n      // Store the Consumer into the pending list.\n      this._pendingResumeConsumers.set(consumer.id, consumer);\n      // There is no Consumer resume in progress, do it now.\n      queueMicrotask(() => {\n        if (this._closed) {\n          return;\n        }\n        if (this._consumerResumeInProgress === false) {\n          this.resumePendingConsumers();\n        }\n      });\n    });\n    consumer.on('@getstats', (callback, errback) => {\n      if (this._closed) {\n        return errback(new errors_1.InvalidStateError('closed'));\n      }\n      this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);\n    });\n  }\n  handleDataProducer(dataProducer) {\n    dataProducer.on('@close', () => {\n      this._dataProducers.delete(dataProducer.id);\n    });\n  }\n  handleDataConsumer(dataConsumer) {\n    dataConsumer.on('@close', () => {\n      this._dataConsumers.delete(dataConsumer.id);\n    });\n  }\n}\nexports.Transport = Transport;","map":{"version":3,"names":["Object","defineProperty","exports","value","Transport","awaitqueue_1","require","Logger_1","enhancedEvents_1","errors_1","utils","ortc","Producer_1","Consumer_1","DataProducer_1","DataConsumer_1","logger","Logger","ConsumerCreationTask","consumerOptions","promise","resolve","reject","constructor","Promise","EnhancedEventEmitter","_id","_closed","_direction","_extendedRtpCapabilities","_canProduceByKind","_maxSctpMessageSize","_handler","_iceGatheringState","_connectionState","_appData","_producers","Map","_consumers","_dataProducers","_dataConsumers","_probatorConsumerCreated","_awaitQueue","AwaitQueue","_pendingConsumerTasks","_consumerCreationInProgress","_pendingPauseConsumers","_consumerPauseInProgress","_pendingResumeConsumers","_consumerResumeInProgress","_pendingCloseConsumers","_consumerCloseInProgress","_observer","direction","id","iceParameters","iceCandidates","dtlsParameters","sctpParameters","iceServers","iceTransportPolicy","additionalSettings","proprietaryConstraints","appData","handlerFactory","extendedRtpCapabilities","canProduceByKind","debug","maxMessageSize","clonedAdditionalSettings","clone","bundlePolicy","rtcpMuxPolicy","sdpSemantics","run","handleHandler","closed","handler","iceGatheringState","connectionState","observer","close","stop","producer","values","transportClosed","clear","consumer","dataProducer","dataConsumer","safeEmit","getStats","InvalidStateError","getTransportStats","restartIce","TypeError","push","updateIceServers","Array","isArray","produce","track","encodings","codecOptions","codec","stopTracks","disableTrackOnPause","zeroRtpOnPause","onRtpSender","UnsupportedError","kind","readyState","listenerCount","normalizedEncodings","length","undefined","map","encoding","normalizedEncoding","active","dtx","scalabilityMode","scaleResolutionDownBy","maxBitrate","maxFramerate","adaptivePtime","priority","networkPriority","localId","rtpParameters","rtpSender","send","validateRtpParameters","Producer","set","handleProducer","error","stopSending","catch","error2","consume","producerId","streamId","onRtpReceiver","clonedRtpParameters","canConsume","canReceive","consumerCreationTask","queueMicrotask","createPendingConsumers","produceData","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","dataChannel","sctpStreamParameters","sendDataChannel","validateSctpStreamParameters","DataProducer","handleDataProducer","consumeData","dataProducerId","clonedSctpStreamParameters","receiveDataChannel","DataConsumer","handleDataConsumer","pendingConsumerTasks","videoConsumerForProbator","optionsList","task","trackId","results","receive","idx","result","rtpReceiver","Consumer","handleConsumer","probatorRtpParameters","generateProbatorRtpParameters","then","pausePendingConsumers","size","pendingPauseConsumers","from","localIds","pauseReceiving","resumePendingConsumers","pendingResumeConsumers","resumeReceiving","closePendingConsumers","pendingCloseConsumers","stopReceiving","on","callback","errback","event","warn","url","address","port","errorCode","errorText","delete","pauseSending","resumeSending","replaceTrack","spatialLayer","setMaxSpatialLayer","params","setRtpEncodingParameters","getSenderStats","has","getReceiverStats"],"sources":["/Users/user/turn/turn-front/node_modules/mediasoup-client/lib/Transport.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst awaitqueue_1 = require(\"awaitqueue\");\nconst Logger_1 = require(\"./Logger\");\nconst enhancedEvents_1 = require(\"./enhancedEvents\");\nconst errors_1 = require(\"./errors\");\nconst utils = require(\"./utils\");\nconst ortc = require(\"./ortc\");\nconst Producer_1 = require(\"./Producer\");\nconst Consumer_1 = require(\"./Consumer\");\nconst DataProducer_1 = require(\"./DataProducer\");\nconst DataConsumer_1 = require(\"./DataConsumer\");\nconst logger = new Logger_1.Logger('Transport');\nclass ConsumerCreationTask {\n    consumerOptions;\n    promise;\n    resolve;\n    reject;\n    constructor(consumerOptions) {\n        this.consumerOptions = consumerOptions;\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nclass Transport extends enhancedEvents_1.EnhancedEventEmitter {\n    // Id.\n    _id;\n    // Closed flag.\n    _closed = false;\n    // Direction.\n    _direction;\n    // Extended RTP capabilities.\n    _extendedRtpCapabilities;\n    // Whether we can produce audio/video based on computed extended RTP\n    // capabilities.\n    _canProduceByKind;\n    // SCTP max message size if enabled, null otherwise.\n    _maxSctpMessageSize;\n    // RTC handler isntance.\n    _handler;\n    // Transport ICE gathering state.\n    _iceGatheringState = 'new';\n    // Transport connection state.\n    _connectionState = 'new';\n    // App custom data.\n    _appData;\n    // Map of Producers indexed by id.\n    _producers = new Map();\n    // Map of Consumers indexed by id.\n    _consumers = new Map();\n    // Map of DataProducers indexed by id.\n    _dataProducers = new Map();\n    // Map of DataConsumers indexed by id.\n    _dataConsumers = new Map();\n    // Whether the Consumer for RTP probation has been created.\n    _probatorConsumerCreated = false;\n    // AwaitQueue instance to make async tasks happen sequentially.\n    _awaitQueue = new awaitqueue_1.AwaitQueue();\n    // Consumer creation tasks awaiting to be processed.\n    _pendingConsumerTasks = [];\n    // Consumer creation in progress flag.\n    _consumerCreationInProgress = false;\n    // Consumers pending to be paused.\n    _pendingPauseConsumers = new Map();\n    // Consumer pause in progress flag.\n    _consumerPauseInProgress = false;\n    // Consumers pending to be resumed.\n    _pendingResumeConsumers = new Map();\n    // Consumer resume in progress flag.\n    _consumerResumeInProgress = false;\n    // Consumers pending to be closed.\n    _pendingCloseConsumers = new Map();\n    // Consumer close in progress flag.\n    _consumerCloseInProgress = false;\n    // Observer instance.\n    _observer = new enhancedEvents_1.EnhancedEventEmitter();\n    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind, }) {\n        super();\n        logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n        this._id = id;\n        this._direction = direction;\n        this._extendedRtpCapabilities = extendedRtpCapabilities;\n        this._canProduceByKind = canProduceByKind;\n        this._maxSctpMessageSize = sctpParameters\n            ? sctpParameters.maxMessageSize\n            : null;\n        // Clone and sanitize additionalSettings.\n        const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};\n        delete clonedAdditionalSettings.iceServers;\n        delete clonedAdditionalSettings.iceTransportPolicy;\n        delete clonedAdditionalSettings.bundlePolicy;\n        delete clonedAdditionalSettings.rtcpMuxPolicy;\n        delete clonedAdditionalSettings.sdpSemantics;\n        this._handler = handlerFactory();\n        this._handler.run({\n            direction,\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            iceServers,\n            iceTransportPolicy,\n            additionalSettings: clonedAdditionalSettings,\n            proprietaryConstraints,\n            extendedRtpCapabilities,\n        });\n        this._appData = appData ?? {};\n        this.handleHandler();\n    }\n    /**\n     * Transport id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Whether the Transport is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Transport direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * RTC handler instance.\n     */\n    get handler() {\n        return this._handler;\n    }\n    /**\n     * ICE gathering state.\n     */\n    get iceGatheringState() {\n        return this._iceGatheringState;\n    }\n    /**\n     * Connection state.\n     */\n    get connectionState() {\n        return this._connectionState;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * App custom data setter.\n     */\n    set appData(appData) {\n        this._appData = appData;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Close the Transport.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('close()');\n        this._closed = true;\n        // Stop the AwaitQueue.\n        this._awaitQueue.stop();\n        // Close the handler.\n        this._handler.close();\n        // Change connection state to 'closed' since the handler may not emit\n        // '@connectionstatechange' event.\n        this._connectionState = 'closed';\n        // Close all Producers.\n        for (const producer of this._producers.values()) {\n            producer.transportClosed();\n        }\n        this._producers.clear();\n        // Close all Consumers.\n        for (const consumer of this._consumers.values()) {\n            consumer.transportClosed();\n        }\n        this._consumers.clear();\n        // Close all DataProducers.\n        for (const dataProducer of this._dataProducers.values()) {\n            dataProducer.transportClosed();\n        }\n        this._dataProducers.clear();\n        // Close all DataConsumers.\n        for (const dataConsumer of this._dataConsumers.values()) {\n            dataConsumer.transportClosed();\n        }\n        this._dataConsumers.clear();\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated Transport (RTCPeerConnection) stats.\n     *\n     * @returns {RTCStatsReport}\n     */\n    async getStats() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        return this._handler.getTransportStats();\n    }\n    /**\n     * Restart ICE connection.\n     */\n    async restartIce({ iceParameters, }) {\n        logger.debug('restartIce()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (!iceParameters) {\n            throw new TypeError('missing iceParameters');\n        }\n        // Enqueue command.\n        return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), 'transport.restartIce()');\n    }\n    /**\n     * Update ICE servers.\n     */\n    async updateIceServers({ iceServers, } = {}) {\n        logger.debug('updateIceServers()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (!Array.isArray(iceServers)) {\n            throw new TypeError('missing iceServers');\n        }\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');\n    }\n    /**\n     * Create a Producer.\n     */\n    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {}, } = {}) {\n        logger.debug('produce() [track:%o]', track);\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (!track) {\n            throw new TypeError('missing track');\n        }\n        else if (this._direction !== 'send') {\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        }\n        else if (!this._canProduceByKind[track.kind]) {\n            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\n        }\n        else if (track.readyState === 'ended') {\n            throw new errors_1.InvalidStateError('track ended');\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (this.listenerCount('produce') === 0) {\n            throw new TypeError('no \"produce\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        // Enqueue command.\n        return (this._awaitQueue\n            .push(async () => {\n            let normalizedEncodings;\n            if (encodings && !Array.isArray(encodings)) {\n                throw TypeError('encodings must be an array');\n            }\n            else if (encodings && encodings.length === 0) {\n                normalizedEncodings = undefined;\n            }\n            else if (encodings) {\n                normalizedEncodings = encodings.map((encoding) => {\n                    const normalizedEncoding = { active: true };\n                    if (encoding.active === false) {\n                        normalizedEncoding.active = false;\n                    }\n                    if (typeof encoding.dtx === 'boolean') {\n                        normalizedEncoding.dtx = encoding.dtx;\n                    }\n                    if (typeof encoding.scalabilityMode === 'string') {\n                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n                    }\n                    if (typeof encoding.scaleResolutionDownBy === 'number') {\n                        normalizedEncoding.scaleResolutionDownBy =\n                            encoding.scaleResolutionDownBy;\n                    }\n                    if (typeof encoding.maxBitrate === 'number') {\n                        normalizedEncoding.maxBitrate = encoding.maxBitrate;\n                    }\n                    if (typeof encoding.maxFramerate === 'number') {\n                        normalizedEncoding.maxFramerate = encoding.maxFramerate;\n                    }\n                    if (typeof encoding.adaptivePtime === 'boolean') {\n                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n                    }\n                    if (typeof encoding.priority === 'string') {\n                        normalizedEncoding.priority = encoding.priority;\n                    }\n                    if (typeof encoding.networkPriority === 'string') {\n                        normalizedEncoding.networkPriority = encoding.networkPriority;\n                    }\n                    return normalizedEncoding;\n                });\n            }\n            const { localId, rtpParameters, rtpSender } = await this._handler.send({\n                track,\n                encodings: normalizedEncodings,\n                codecOptions,\n                codec,\n                onRtpSender,\n            });\n            try {\n                // This will fill rtpParameters's missing fields with default values.\n                ortc.validateRtpParameters(rtpParameters);\n                const { id } = await new Promise((resolve, reject) => {\n                    this.safeEmit('produce', {\n                        kind: track.kind,\n                        rtpParameters,\n                        appData,\n                    }, resolve, reject);\n                });\n                const producer = new Producer_1.Producer({\n                    id,\n                    localId,\n                    rtpSender,\n                    track,\n                    rtpParameters,\n                    stopTracks,\n                    disableTrackOnPause,\n                    zeroRtpOnPause,\n                    appData,\n                });\n                this._producers.set(producer.id, producer);\n                this.handleProducer(producer);\n                // Emit observer event.\n                this._observer.safeEmit('newproducer', producer);\n                return producer;\n            }\n            catch (error) {\n                this._handler.stopSending(localId).catch(() => { });\n                throw error;\n            }\n        }, 'transport.produce()')\n            // This catch is needed to stop the given track if the command above\n            // failed due to closed Transport.\n            .catch((error) => {\n            if (stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error2) { }\n            }\n            throw error;\n        }));\n    }\n    /**\n     * Create a Consumer to consume a remote Producer.\n     */\n    async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {}, }) {\n        logger.debug('consume()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._direction !== 'recv') {\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        }\n        else if (typeof id !== 'string') {\n            throw new TypeError('missing id');\n        }\n        else if (typeof producerId !== 'string') {\n            throw new TypeError('missing producerId');\n        }\n        else if (kind !== 'audio' && kind !== 'video') {\n            throw new TypeError(`invalid kind '${kind}'`);\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        // Clone given RTP parameters to not modify input data.\n        const clonedRtpParameters = utils.clone(rtpParameters);\n        // Ensure the device can consume it.\n        const canConsume = ortc.canReceive(clonedRtpParameters, this._extendedRtpCapabilities);\n        if (!canConsume) {\n            throw new errors_1.UnsupportedError('cannot consume this Producer');\n        }\n        const consumerCreationTask = new ConsumerCreationTask({\n            id,\n            producerId,\n            kind,\n            rtpParameters: clonedRtpParameters,\n            streamId,\n            onRtpReceiver,\n            appData,\n        });\n        // Store the Consumer creation task.\n        this._pendingConsumerTasks.push(consumerCreationTask);\n        // There is no Consumer creation in progress, create it now.\n        queueMicrotask(() => {\n            if (this._closed) {\n                return;\n            }\n            if (this._consumerCreationInProgress === false) {\n                this.createPendingConsumers();\n            }\n        });\n        return consumerCreationTask.promise;\n    }\n    /**\n     * Create a DataProducer\n     */\n    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {}, } = {}) {\n        logger.debug('produceData()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._direction !== 'send') {\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        }\n        else if (!this._maxSctpMessageSize) {\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (this.listenerCount('producedata') === 0) {\n            throw new TypeError('no \"producedata\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        if (maxPacketLifeTime || maxRetransmits) {\n            ordered = false;\n        }\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({\n                ordered,\n                maxPacketLifeTime,\n                maxRetransmits,\n                label,\n                protocol,\n            });\n            // This will fill sctpStreamParameters's missing fields with default values.\n            ortc.validateSctpStreamParameters(sctpStreamParameters);\n            const { id } = await new Promise((resolve, reject) => {\n                this.safeEmit('producedata', {\n                    sctpStreamParameters,\n                    label,\n                    protocol,\n                    appData,\n                }, resolve, reject);\n            });\n            const dataProducer = new DataProducer_1.DataProducer({\n                id,\n                dataChannel,\n                sctpStreamParameters,\n                appData,\n            });\n            this._dataProducers.set(dataProducer.id, dataProducer);\n            this.handleDataProducer(dataProducer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataproducer', dataProducer);\n            return dataProducer;\n        }, 'transport.produceData()');\n    }\n    /**\n     * Create a DataConsumer\n     */\n    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {}, }) {\n        logger.debug('consumeData()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._direction !== 'recv') {\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        }\n        else if (!this._maxSctpMessageSize) {\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        }\n        else if (typeof id !== 'string') {\n            throw new TypeError('missing id');\n        }\n        else if (typeof dataProducerId !== 'string') {\n            throw new TypeError('missing dataProducerId');\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        // Clone given SCTP stream parameters to not modify input data.\n        const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);\n        // This may throw.\n        ortc.validateSctpStreamParameters(clonedSctpStreamParameters);\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel } = await this._handler.receiveDataChannel({\n                sctpStreamParameters: clonedSctpStreamParameters,\n                label,\n                protocol,\n            });\n            const dataConsumer = new DataConsumer_1.DataConsumer({\n                id,\n                dataProducerId,\n                dataChannel,\n                sctpStreamParameters: clonedSctpStreamParameters,\n                appData,\n            });\n            this._dataConsumers.set(dataConsumer.id, dataConsumer);\n            this.handleDataConsumer(dataConsumer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataconsumer', dataConsumer);\n            return dataConsumer;\n        }, 'transport.consumeData()');\n    }\n    // This method is guaranteed to never throw.\n    createPendingConsumers() {\n        this._consumerCreationInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingConsumerTasks.length === 0) {\n                logger.debug('createPendingConsumers() | there is no Consumer to be created');\n                return;\n            }\n            const pendingConsumerTasks = [...this._pendingConsumerTasks];\n            // Clear pending Consumer tasks.\n            this._pendingConsumerTasks = [];\n            // Video Consumer in order to create the probator.\n            let videoConsumerForProbator = undefined;\n            // Fill options list.\n            const optionsList = [];\n            for (const task of pendingConsumerTasks) {\n                const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;\n                optionsList.push({\n                    trackId: id,\n                    kind: kind,\n                    rtpParameters,\n                    streamId,\n                    onRtpReceiver,\n                });\n            }\n            try {\n                const results = await this._handler.receive(optionsList);\n                for (let idx = 0; idx < results.length; ++idx) {\n                    const task = pendingConsumerTasks[idx];\n                    const result = results[idx];\n                    const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;\n                    const { localId, rtpReceiver, track } = result;\n                    const consumer = new Consumer_1.Consumer({\n                        id: id,\n                        localId,\n                        producerId: producerId,\n                        rtpReceiver,\n                        track,\n                        rtpParameters,\n                        appData: appData,\n                    });\n                    this._consumers.set(consumer.id, consumer);\n                    this.handleConsumer(consumer);\n                    // If this is the first video Consumer and the Consumer for RTP probation\n                    // has not yet been created, it's time to create it.\n                    if (!this._probatorConsumerCreated &&\n                        !videoConsumerForProbator &&\n                        kind === 'video') {\n                        videoConsumerForProbator = consumer;\n                    }\n                    // Emit observer event.\n                    this._observer.safeEmit('newconsumer', consumer);\n                    task.resolve(consumer);\n                }\n            }\n            catch (error) {\n                for (const task of pendingConsumerTasks) {\n                    task.reject(error);\n                }\n            }\n            // If RTP probation must be handled, do it now.\n            if (videoConsumerForProbator) {\n                try {\n                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);\n                    await this._handler.receive([\n                        {\n                            trackId: 'probator',\n                            kind: 'video',\n                            rtpParameters: probatorRtpParameters,\n                        },\n                    ]);\n                    logger.debug('createPendingConsumers() | Consumer for RTP probation created');\n                    this._probatorConsumerCreated = true;\n                }\n                catch (error) {\n                    logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);\n                }\n            }\n        }, 'transport.createPendingConsumers()')\n            .then(() => {\n            this._consumerCreationInProgress = false;\n            // There are pending Consumer tasks, enqueue their creation.\n            if (this._pendingConsumerTasks.length > 0) {\n                this.createPendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    pausePendingConsumers() {\n        this._consumerPauseInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingPauseConsumers.size === 0) {\n                logger.debug('pausePendingConsumers() | there is no Consumer to be paused');\n                return;\n            }\n            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());\n            // Clear pending pause Consumer map.\n            this._pendingPauseConsumers.clear();\n            try {\n                const localIds = pendingPauseConsumers.map(consumer => consumer.localId);\n                await this._handler.pauseReceiving(localIds);\n            }\n            catch (error) {\n                logger.error('pausePendingConsumers() | failed to pause Consumers:', error);\n            }\n        }, 'transport.pausePendingConsumers')\n            .then(() => {\n            this._consumerPauseInProgress = false;\n            // There are pending Consumers to be paused, do it.\n            if (this._pendingPauseConsumers.size > 0) {\n                this.pausePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    resumePendingConsumers() {\n        this._consumerResumeInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingResumeConsumers.size === 0) {\n                logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');\n                return;\n            }\n            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());\n            // Clear pending resume Consumer map.\n            this._pendingResumeConsumers.clear();\n            try {\n                const localIds = pendingResumeConsumers.map(consumer => consumer.localId);\n                await this._handler.resumeReceiving(localIds);\n            }\n            catch (error) {\n                logger.error('resumePendingConsumers() | failed to resume Consumers:', error);\n            }\n        }, 'transport.resumePendingConsumers')\n            .then(() => {\n            this._consumerResumeInProgress = false;\n            // There are pending Consumer to be resumed, do it.\n            if (this._pendingResumeConsumers.size > 0) {\n                this.resumePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    closePendingConsumers() {\n        this._consumerCloseInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingCloseConsumers.size === 0) {\n                logger.debug('closePendingConsumers() | there is no Consumer to be closed');\n                return;\n            }\n            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());\n            // Clear pending close Consumer map.\n            this._pendingCloseConsumers.clear();\n            try {\n                await this._handler.stopReceiving(pendingCloseConsumers.map(consumer => consumer.localId));\n            }\n            catch (error) {\n                logger.error('closePendingConsumers() | failed to close Consumers:', error);\n            }\n        }, 'transport.closePendingConsumers')\n            .then(() => {\n            this._consumerCloseInProgress = false;\n            // There are pending Consumer to be resumed, do it.\n            if (this._pendingCloseConsumers.size > 0) {\n                this.closePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    handleHandler() {\n        const handler = this._handler;\n        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {\n            if (this._closed) {\n                errback(new errors_1.InvalidStateError('closed'));\n                return;\n            }\n            this.safeEmit('connect', { dtlsParameters }, callback, errback);\n        });\n        handler.on('@icegatheringstatechange', (iceGatheringState) => {\n            if (iceGatheringState === this._iceGatheringState) {\n                return;\n            }\n            logger.debug('ICE gathering state changed to %s', iceGatheringState);\n            this._iceGatheringState = iceGatheringState;\n            if (!this._closed) {\n                this.safeEmit('icegatheringstatechange', iceGatheringState);\n            }\n        });\n        handler.on('@icecandidateerror', (event) => {\n            logger.warn(`ICE candidate error [url:${event.url}, localAddress:${event.address}, localPort:${event.port}]: ${event.errorCode} \"${event.errorText}\"`);\n            this.safeEmit('icecandidateerror', event);\n        });\n        handler.on('@connectionstatechange', (connectionState) => {\n            if (connectionState === this._connectionState) {\n                return;\n            }\n            logger.debug('connection state changed to %s', connectionState);\n            this._connectionState = connectionState;\n            if (!this._closed) {\n                this.safeEmit('connectionstatechange', connectionState);\n            }\n        });\n    }\n    handleProducer(producer) {\n        producer.on('@close', () => {\n            this._producers.delete(producer.id);\n            if (this._closed) {\n                return;\n            }\n            this._awaitQueue\n                .push(async () => await this._handler.stopSending(producer.localId), 'producer @close event')\n                .catch((error) => logger.warn('producer.close() failed:%o', error));\n        });\n        producer.on('@pause', (callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.pauseSending(producer.localId), 'producer @pause event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@resume', (callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.resumeSending(producer.localId), 'producer @resume event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@replacetrack', (track, callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@getstats', (callback, errback) => {\n            if (this._closed) {\n                return errback(new errors_1.InvalidStateError('closed'));\n            }\n            this._handler\n                .getSenderStats(producer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    handleConsumer(consumer) {\n        consumer.on('@close', () => {\n            this._consumers.delete(consumer.id);\n            this._pendingPauseConsumers.delete(consumer.id);\n            this._pendingResumeConsumers.delete(consumer.id);\n            if (this._closed) {\n                return;\n            }\n            // Store the Consumer into the close list.\n            this._pendingCloseConsumers.set(consumer.id, consumer);\n            // There is no Consumer close in progress, do it now.\n            if (this._consumerCloseInProgress === false) {\n                this.closePendingConsumers();\n            }\n        });\n        consumer.on('@pause', () => {\n            // If Consumer is pending to be resumed, remove from pending resume list.\n            if (this._pendingResumeConsumers.has(consumer.id)) {\n                this._pendingResumeConsumers.delete(consumer.id);\n            }\n            // Store the Consumer into the pending list.\n            this._pendingPauseConsumers.set(consumer.id, consumer);\n            // There is no Consumer pause in progress, do it now.\n            queueMicrotask(() => {\n                if (this._closed) {\n                    return;\n                }\n                if (this._consumerPauseInProgress === false) {\n                    this.pausePendingConsumers();\n                }\n            });\n        });\n        consumer.on('@resume', () => {\n            // If Consumer is pending to be paused, remove from pending pause list.\n            if (this._pendingPauseConsumers.has(consumer.id)) {\n                this._pendingPauseConsumers.delete(consumer.id);\n            }\n            // Store the Consumer into the pending list.\n            this._pendingResumeConsumers.set(consumer.id, consumer);\n            // There is no Consumer resume in progress, do it now.\n            queueMicrotask(() => {\n                if (this._closed) {\n                    return;\n                }\n                if (this._consumerResumeInProgress === false) {\n                    this.resumePendingConsumers();\n                }\n            });\n        });\n        consumer.on('@getstats', (callback, errback) => {\n            if (this._closed) {\n                return errback(new errors_1.InvalidStateError('closed'));\n            }\n            this._handler\n                .getReceiverStats(consumer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    handleDataProducer(dataProducer) {\n        dataProducer.on('@close', () => {\n            this._dataProducers.delete(dataProducer.id);\n        });\n    }\n    handleDataConsumer(dataConsumer) {\n        dataConsumer.on('@close', () => {\n            this._dataConsumers.delete(dataConsumer.id);\n        });\n    }\n}\nexports.Transport = Transport;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}