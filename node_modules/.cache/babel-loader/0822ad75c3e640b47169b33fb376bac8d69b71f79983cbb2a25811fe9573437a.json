{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Producer = void 0;\nconst Logger_1 = require(\"./Logger\");\nconst enhancedEvents_1 = require(\"./enhancedEvents\");\nconst errors_1 = require(\"./errors\");\nconst logger = new Logger_1.Logger('Producer');\nclass Producer extends enhancedEvents_1.EnhancedEventEmitter {\n  // Id.\n  _id;\n  // Local id.\n  _localId;\n  // Closed flag.\n  _closed = false;\n  // Associated RTCRtpSender.\n  _rtpSender;\n  // Local track.\n  _track;\n  // Producer kind.\n  _kind;\n  // RTP parameters.\n  _rtpParameters;\n  // Paused flag.\n  _paused;\n  // Video max spatial layer.\n  _maxSpatialLayer;\n  // Whether the Producer should call stop() in given tracks.\n  _stopTracks;\n  // Whether the Producer should set track.enabled = false when paused.\n  _disableTrackOnPause;\n  // Whether we should replace the RTCRtpSender.track with null when paused.\n  _zeroRtpOnPause;\n  // App custom data.\n  _appData;\n  // Observer instance.\n  _observer = new enhancedEvents_1.EnhancedEventEmitter();\n  constructor({\n    id,\n    localId,\n    rtpSender,\n    track,\n    rtpParameters,\n    stopTracks,\n    disableTrackOnPause,\n    zeroRtpOnPause,\n    appData\n  }) {\n    super();\n    logger.debug('constructor()');\n    this._id = id;\n    this._localId = localId;\n    this._rtpSender = rtpSender;\n    this._track = track;\n    this._kind = track.kind;\n    this._rtpParameters = rtpParameters;\n    this._paused = disableTrackOnPause ? !track.enabled : false;\n    this._maxSpatialLayer = undefined;\n    this._stopTracks = stopTracks;\n    this._disableTrackOnPause = disableTrackOnPause;\n    this._zeroRtpOnPause = zeroRtpOnPause;\n    this._appData = appData ?? {};\n    this.onTrackEnded = this.onTrackEnded.bind(this);\n    // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the\n    // '@replacetrack' event here, so RTCRtpSender.track won't be null.\n    this.handleTrack();\n  }\n  /**\n   * Producer id.\n   */\n  get id() {\n    return this._id;\n  }\n  /**\n   * Local id.\n   */\n  get localId() {\n    return this._localId;\n  }\n  /**\n   * Whether the Producer is closed.\n   */\n  get closed() {\n    return this._closed;\n  }\n  /**\n   * Media kind.\n   */\n  get kind() {\n    return this._kind;\n  }\n  /**\n   * Associated RTCRtpSender.\n   */\n  get rtpSender() {\n    return this._rtpSender;\n  }\n  /**\n   * The associated track.\n   */\n  get track() {\n    return this._track;\n  }\n  /**\n   * RTP parameters.\n   */\n  get rtpParameters() {\n    return this._rtpParameters;\n  }\n  /**\n   * Whether the Producer is paused.\n   */\n  get paused() {\n    return this._paused;\n  }\n  /**\n   * Max spatial layer.\n   *\n   * @type {Number | undefined}\n   */\n  get maxSpatialLayer() {\n    return this._maxSpatialLayer;\n  }\n  /**\n   * App custom data.\n   */\n  get appData() {\n    return this._appData;\n  }\n  /**\n   * App custom data setter.\n   */\n  set appData(appData) {\n    this._appData = appData;\n  }\n  get observer() {\n    return this._observer;\n  }\n  /**\n   * Closes the Producer.\n   */\n  close() {\n    if (this._closed) {\n      return;\n    }\n    logger.debug('close()');\n    this._closed = true;\n    this.destroyTrack();\n    this.emit('@close');\n    // Emit observer event.\n    this._observer.safeEmit('close');\n  }\n  /**\n   * Transport was closed.\n   */\n  transportClosed() {\n    if (this._closed) {\n      return;\n    }\n    logger.debug('transportClosed()');\n    this._closed = true;\n    this.destroyTrack();\n    this.safeEmit('transportclose');\n    // Emit observer event.\n    this._observer.safeEmit('close');\n  }\n  /**\n   * Get associated RTCRtpSender stats.\n   */\n  async getStats() {\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    }\n    return new Promise((resolve, reject) => {\n      this.safeEmit('@getstats', resolve, reject);\n    });\n  }\n  /**\n   * Pauses sending media.\n   */\n  pause() {\n    logger.debug('pause()');\n    if (this._closed) {\n      logger.error('pause() | Producer closed');\n      return;\n    }\n    this._paused = true;\n    if (this._track && this._disableTrackOnPause) {\n      this._track.enabled = false;\n    }\n    if (this._zeroRtpOnPause) {\n      new Promise((resolve, reject) => {\n        this.safeEmit('@pause', resolve, reject);\n      }).catch(() => {});\n    }\n    // Emit observer event.\n    this._observer.safeEmit('pause');\n  }\n  /**\n   * Resumes sending media.\n   */\n  resume() {\n    logger.debug('resume()');\n    if (this._closed) {\n      logger.error('resume() | Producer closed');\n      return;\n    }\n    this._paused = false;\n    if (this._track && this._disableTrackOnPause) {\n      this._track.enabled = true;\n    }\n    if (this._zeroRtpOnPause) {\n      new Promise((resolve, reject) => {\n        this.safeEmit('@resume', resolve, reject);\n      }).catch(() => {});\n    }\n    // Emit observer event.\n    this._observer.safeEmit('resume');\n  }\n  /**\n   * Replaces the current track with a new one or null.\n   */\n  async replaceTrack({\n    track\n  }) {\n    logger.debug('replaceTrack() [track:%o]', track);\n    if (this._closed) {\n      // This must be done here. Otherwise there is no chance to stop the given\n      // track.\n      if (track && this._stopTracks) {\n        try {\n          track.stop();\n        } catch (error) {}\n      }\n      throw new errors_1.InvalidStateError('closed');\n    } else if (track && track.readyState === 'ended') {\n      throw new errors_1.InvalidStateError('track ended');\n    }\n    // Do nothing if this is the same track as the current handled one.\n    if (track === this._track) {\n      logger.debug('replaceTrack() | same track, ignored');\n      return;\n    }\n    await new Promise((resolve, reject) => {\n      this.safeEmit('@replacetrack', track, resolve, reject);\n    });\n    // Destroy the previous track.\n    this.destroyTrack();\n    // Set the new track.\n    this._track = track;\n    // If this Producer was paused/resumed and the state of the new\n    // track does not match, fix it.\n    if (this._track && this._disableTrackOnPause) {\n      if (!this._paused) {\n        this._track.enabled = true;\n      } else if (this._paused) {\n        this._track.enabled = false;\n      }\n    }\n    // Handle the effective track.\n    this.handleTrack();\n  }\n  /**\n   * Sets the video max spatial layer to be sent.\n   */\n  async setMaxSpatialLayer(spatialLayer) {\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (this._kind !== 'video') {\n      throw new errors_1.UnsupportedError('not a video Producer');\n    } else if (typeof spatialLayer !== 'number') {\n      throw new TypeError('invalid spatialLayer');\n    }\n    if (spatialLayer === this._maxSpatialLayer) {\n      return;\n    }\n    await new Promise((resolve, reject) => {\n      this.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);\n    }).catch(() => {});\n    this._maxSpatialLayer = spatialLayer;\n  }\n  async setRtpEncodingParameters(params) {\n    if (this._closed) {\n      throw new errors_1.InvalidStateError('closed');\n    } else if (typeof params !== 'object') {\n      throw new TypeError('invalid params');\n    }\n    await new Promise((resolve, reject) => {\n      this.safeEmit('@setrtpencodingparameters', params, resolve, reject);\n    });\n  }\n  onTrackEnded() {\n    logger.debug('track \"ended\" event');\n    this.safeEmit('trackended');\n    // Emit observer event.\n    this._observer.safeEmit('trackended');\n  }\n  handleTrack() {\n    if (!this._track) {\n      return;\n    }\n    this._track.addEventListener('ended', this.onTrackEnded);\n  }\n  destroyTrack() {\n    if (!this._track) {\n      return;\n    }\n    try {\n      this._track.removeEventListener('ended', this.onTrackEnded);\n      // Just stop the track unless the app set stopTracks: false.\n      if (this._stopTracks) {\n        this._track.stop();\n      }\n    } catch (error) {}\n  }\n}\nexports.Producer = Producer;","map":{"version":3,"names":["Object","defineProperty","exports","value","Producer","Logger_1","require","enhancedEvents_1","errors_1","logger","Logger","EnhancedEventEmitter","_id","_localId","_closed","_rtpSender","_track","_kind","_rtpParameters","_paused","_maxSpatialLayer","_stopTracks","_disableTrackOnPause","_zeroRtpOnPause","_appData","_observer","constructor","id","localId","rtpSender","track","rtpParameters","stopTracks","disableTrackOnPause","zeroRtpOnPause","appData","debug","kind","enabled","undefined","onTrackEnded","bind","handleTrack","closed","paused","maxSpatialLayer","observer","close","destroyTrack","emit","safeEmit","transportClosed","getStats","InvalidStateError","Promise","resolve","reject","pause","error","catch","resume","replaceTrack","stop","readyState","setMaxSpatialLayer","spatialLayer","UnsupportedError","TypeError","setRtpEncodingParameters","params","addEventListener","removeEventListener"],"sources":["/Users/user/turn/turn-front/node_modules/mediasoup-client/lib/Producer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Producer = void 0;\nconst Logger_1 = require(\"./Logger\");\nconst enhancedEvents_1 = require(\"./enhancedEvents\");\nconst errors_1 = require(\"./errors\");\nconst logger = new Logger_1.Logger('Producer');\nclass Producer extends enhancedEvents_1.EnhancedEventEmitter {\n    // Id.\n    _id;\n    // Local id.\n    _localId;\n    // Closed flag.\n    _closed = false;\n    // Associated RTCRtpSender.\n    _rtpSender;\n    // Local track.\n    _track;\n    // Producer kind.\n    _kind;\n    // RTP parameters.\n    _rtpParameters;\n    // Paused flag.\n    _paused;\n    // Video max spatial layer.\n    _maxSpatialLayer;\n    // Whether the Producer should call stop() in given tracks.\n    _stopTracks;\n    // Whether the Producer should set track.enabled = false when paused.\n    _disableTrackOnPause;\n    // Whether we should replace the RTCRtpSender.track with null when paused.\n    _zeroRtpOnPause;\n    // App custom data.\n    _appData;\n    // Observer instance.\n    _observer = new enhancedEvents_1.EnhancedEventEmitter();\n    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }) {\n        super();\n        logger.debug('constructor()');\n        this._id = id;\n        this._localId = localId;\n        this._rtpSender = rtpSender;\n        this._track = track;\n        this._kind = track.kind;\n        this._rtpParameters = rtpParameters;\n        this._paused = disableTrackOnPause ? !track.enabled : false;\n        this._maxSpatialLayer = undefined;\n        this._stopTracks = stopTracks;\n        this._disableTrackOnPause = disableTrackOnPause;\n        this._zeroRtpOnPause = zeroRtpOnPause;\n        this._appData = appData ?? {};\n        this.onTrackEnded = this.onTrackEnded.bind(this);\n        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the\n        // '@replacetrack' event here, so RTCRtpSender.track won't be null.\n        this.handleTrack();\n    }\n    /**\n     * Producer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Local id.\n     */\n    get localId() {\n        return this._localId;\n    }\n    /**\n     * Whether the Producer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n    get kind() {\n        return this._kind;\n    }\n    /**\n     * Associated RTCRtpSender.\n     */\n    get rtpSender() {\n        return this._rtpSender;\n    }\n    /**\n     * The associated track.\n     */\n    get track() {\n        return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n    get rtpParameters() {\n        return this._rtpParameters;\n    }\n    /**\n     * Whether the Producer is paused.\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Max spatial layer.\n     *\n     * @type {Number | undefined}\n     */\n    get maxSpatialLayer() {\n        return this._maxSpatialLayer;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * App custom data setter.\n     */\n    set appData(appData) {\n        this._appData = appData;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Closes the Producer.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('close()');\n        this._closed = true;\n        this.destroyTrack();\n        this.emit('@close');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this.destroyTrack();\n        this.safeEmit('transportclose');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated RTCRtpSender stats.\n     */\n    async getStats() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        return new Promise((resolve, reject) => {\n            this.safeEmit('@getstats', resolve, reject);\n        });\n    }\n    /**\n     * Pauses sending media.\n     */\n    pause() {\n        logger.debug('pause()');\n        if (this._closed) {\n            logger.error('pause() | Producer closed');\n            return;\n        }\n        this._paused = true;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = false;\n        }\n        if (this._zeroRtpOnPause) {\n            new Promise((resolve, reject) => {\n                this.safeEmit('@pause', resolve, reject);\n            }).catch(() => { });\n        }\n        // Emit observer event.\n        this._observer.safeEmit('pause');\n    }\n    /**\n     * Resumes sending media.\n     */\n    resume() {\n        logger.debug('resume()');\n        if (this._closed) {\n            logger.error('resume() | Producer closed');\n            return;\n        }\n        this._paused = false;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = true;\n        }\n        if (this._zeroRtpOnPause) {\n            new Promise((resolve, reject) => {\n                this.safeEmit('@resume', resolve, reject);\n            }).catch(() => { });\n        }\n        // Emit observer event.\n        this._observer.safeEmit('resume');\n    }\n    /**\n     * Replaces the current track with a new one or null.\n     */\n    async replaceTrack({ track, }) {\n        logger.debug('replaceTrack() [track:%o]', track);\n        if (this._closed) {\n            // This must be done here. Otherwise there is no chance to stop the given\n            // track.\n            if (track && this._stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error) { }\n            }\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (track && track.readyState === 'ended') {\n            throw new errors_1.InvalidStateError('track ended');\n        }\n        // Do nothing if this is the same track as the current handled one.\n        if (track === this._track) {\n            logger.debug('replaceTrack() | same track, ignored');\n            return;\n        }\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@replacetrack', track, resolve, reject);\n        });\n        // Destroy the previous track.\n        this.destroyTrack();\n        // Set the new track.\n        this._track = track;\n        // If this Producer was paused/resumed and the state of the new\n        // track does not match, fix it.\n        if (this._track && this._disableTrackOnPause) {\n            if (!this._paused) {\n                this._track.enabled = true;\n            }\n            else if (this._paused) {\n                this._track.enabled = false;\n            }\n        }\n        // Handle the effective track.\n        this.handleTrack();\n    }\n    /**\n     * Sets the video max spatial layer to be sent.\n     */\n    async setMaxSpatialLayer(spatialLayer) {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._kind !== 'video') {\n            throw new errors_1.UnsupportedError('not a video Producer');\n        }\n        else if (typeof spatialLayer !== 'number') {\n            throw new TypeError('invalid spatialLayer');\n        }\n        if (spatialLayer === this._maxSpatialLayer) {\n            return;\n        }\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);\n        }).catch(() => { });\n        this._maxSpatialLayer = spatialLayer;\n    }\n    async setRtpEncodingParameters(params) {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (typeof params !== 'object') {\n            throw new TypeError('invalid params');\n        }\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@setrtpencodingparameters', params, resolve, reject);\n        });\n    }\n    onTrackEnded() {\n        logger.debug('track \"ended\" event');\n        this.safeEmit('trackended');\n        // Emit observer event.\n        this._observer.safeEmit('trackended');\n    }\n    handleTrack() {\n        if (!this._track) {\n            return;\n        }\n        this._track.addEventListener('ended', this.onTrackEnded);\n    }\n    destroyTrack() {\n        if (!this._track) {\n            return;\n        }\n        try {\n            this._track.removeEventListener('ended', this.onTrackEnded);\n            // Just stop the track unless the app set stopTracks: false.\n            if (this._stopTracks) {\n                this._track.stop();\n            }\n        }\n        catch (error) { }\n    }\n}\nexports.Producer = Producer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}