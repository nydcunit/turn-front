{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractRtpCapabilities = extractRtpCapabilities;\nexports.extractDtlsParameters = extractDtlsParameters;\nexports.getCname = getCname;\nexports.applyCodecParameters = applyCodecParameters;\nconst sdpTransform = require(\"sdp-transform\");\n/**\n * This function must be called with an SDP with 1 m=audio and 1 m=video\n * sections.\n */\nfunction extractRtpCapabilities({\n  sdpObject\n}) {\n  // Map of RtpCodecParameters indexed by payload type.\n  const codecsMap = new Map();\n  // Array of RtpHeaderExtensions.\n  const headerExtensions = [];\n  // Whether a m=audio/video section has been already found.\n  let gotAudio = false;\n  let gotVideo = false;\n  for (const m of sdpObject.media) {\n    const kind = m.type;\n    switch (kind) {\n      case 'audio':\n        {\n          if (gotAudio) {\n            continue;\n          }\n          gotAudio = true;\n          break;\n        }\n      case 'video':\n        {\n          if (gotVideo) {\n            continue;\n          }\n          gotVideo = true;\n          break;\n        }\n      default:\n        {\n          continue;\n        }\n    }\n    // Get codecs.\n    for (const rtp of m.rtp) {\n      const codec = {\n        kind: kind,\n        mimeType: `${kind}/${rtp.codec}`,\n        preferredPayloadType: rtp.payload,\n        clockRate: rtp.rate,\n        channels: rtp.encoding,\n        parameters: {},\n        rtcpFeedback: []\n      };\n      codecsMap.set(codec.preferredPayloadType, codec);\n    }\n    // Get codec parameters.\n    for (const fmtp of m.fmtp ?? []) {\n      const parameters = sdpTransform.parseParams(fmtp.config);\n      const codec = codecsMap.get(fmtp.payload);\n      if (!codec) {\n        continue;\n      }\n      // Specials case to convert parameter value to string.\n      if (parameters?.hasOwnProperty('profile-level-id')) {\n        parameters['profile-level-id'] = String(parameters['profile-level-id']);\n      }\n      codec.parameters = parameters;\n    }\n    // Get RTCP feedback for each codec.\n    for (const fb of m.rtcpFb ?? []) {\n      const feedback = {\n        type: fb.type,\n        parameter: fb.subtype\n      };\n      if (!feedback.parameter) {\n        delete feedback.parameter;\n      }\n      // rtcp-fb payload is not '*', so just apply it to its corresponding\n      // codec.\n      if (fb.payload !== '*') {\n        const codec = codecsMap.get(fb.payload);\n        if (!codec) {\n          continue;\n        }\n        codec.rtcpFeedback.push(feedback);\n      }\n      // If rtcp-fb payload is '*' it must be applied to all codecs with same\n      // kind (with some exceptions such as RTX codec).\n      else {\n        for (const codec of codecsMap.values()) {\n          if (codec.kind === kind && !/.+\\/rtx$/i.test(codec.mimeType)) {\n            codec.rtcpFeedback.push(feedback);\n          }\n        }\n      }\n    }\n    // Get RTP header extensions.\n    for (const ext of m.ext ?? []) {\n      // Ignore encrypted extensions (not yet supported in mediasoup).\n      if (ext['encrypt-uri']) {\n        continue;\n      }\n      const headerExtension = {\n        kind: kind,\n        uri: ext.uri,\n        preferredId: ext.value\n      };\n      headerExtensions.push(headerExtension);\n    }\n  }\n  const rtpCapabilities = {\n    codecs: Array.from(codecsMap.values()),\n    headerExtensions: headerExtensions\n  };\n  return rtpCapabilities;\n}\nfunction extractDtlsParameters({\n  sdpObject\n}) {\n  let setup = sdpObject.setup;\n  let fingerprint = sdpObject.fingerprint;\n  if (!setup || !fingerprint) {\n    const mediaObject = (sdpObject.media ?? []).find(m => m.port !== 0);\n    if (mediaObject) {\n      setup ??= mediaObject.setup;\n      fingerprint ??= mediaObject.fingerprint;\n    }\n  }\n  if (!setup) {\n    throw new Error('no a=setup found at SDP session or media level');\n  } else if (!fingerprint) {\n    throw new Error('no a=fingerprint found at SDP session or media level');\n  }\n  let role;\n  switch (setup) {\n    case 'active':\n      {\n        role = 'client';\n        break;\n      }\n    case 'passive':\n      {\n        role = 'server';\n        break;\n      }\n    case 'actpass':\n      {\n        role = 'auto';\n        break;\n      }\n  }\n  const dtlsParameters = {\n    role,\n    fingerprints: [{\n      algorithm: fingerprint.type,\n      value: fingerprint.hash\n    }]\n  };\n  return dtlsParameters;\n}\nfunction getCname({\n  offerMediaObject\n}) {\n  const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find(line => line.attribute === 'cname');\n  if (!ssrcCnameLine) {\n    return '';\n  }\n  return ssrcCnameLine.value;\n}\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters({\n  offerRtpParameters,\n  answerMediaObject\n}) {\n  for (const codec of offerRtpParameters.codecs) {\n    const mimeType = codec.mimeType.toLowerCase();\n    // Avoid parsing codec parameters for unhandled codecs.\n    if (mimeType !== 'audio/opus') {\n      continue;\n    }\n    const rtp = (answerMediaObject.rtp ?? []).find(r => r.payload === codec.payloadType);\n    if (!rtp) {\n      continue;\n    }\n    // Just in case.\n    answerMediaObject.fmtp = answerMediaObject.fmtp ?? [];\n    let fmtp = answerMediaObject.fmtp.find(f => f.payload === codec.payloadType);\n    if (!fmtp) {\n      fmtp = {\n        payload: codec.payloadType,\n        config: ''\n      };\n      answerMediaObject.fmtp.push(fmtp);\n    }\n    const parameters = sdpTransform.parseParams(fmtp.config);\n    switch (mimeType) {\n      case 'audio/opus':\n        {\n          const spropStereo = codec.parameters['sprop-stereo'];\n          if (spropStereo !== undefined) {\n            parameters['stereo'] = Number(spropStereo) ? 1 : 0;\n          }\n          break;\n        }\n    }\n    // Write the codec fmtp.config back.\n    fmtp.config = '';\n    for (const key of Object.keys(parameters)) {\n      if (fmtp.config) {\n        fmtp.config += ';';\n      }\n      fmtp.config += `${key}=${parameters[key]}`;\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","extractRtpCapabilities","extractDtlsParameters","getCname","applyCodecParameters","sdpTransform","require","sdpObject","codecsMap","Map","headerExtensions","gotAudio","gotVideo","m","media","kind","type","rtp","codec","mimeType","preferredPayloadType","payload","clockRate","rate","channels","encoding","parameters","rtcpFeedback","set","fmtp","parseParams","config","get","hasOwnProperty","String","fb","rtcpFb","feedback","parameter","subtype","push","values","test","ext","headerExtension","uri","preferredId","rtpCapabilities","codecs","Array","from","setup","fingerprint","mediaObject","find","port","Error","role","dtlsParameters","fingerprints","algorithm","hash","offerMediaObject","ssrcCnameLine","ssrcs","line","attribute","offerRtpParameters","answerMediaObject","toLowerCase","r","payloadType","f","spropStereo","undefined","Number","key","keys"],"sources":["/Users/user/turn/turn-front/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractRtpCapabilities = extractRtpCapabilities;\nexports.extractDtlsParameters = extractDtlsParameters;\nexports.getCname = getCname;\nexports.applyCodecParameters = applyCodecParameters;\nconst sdpTransform = require(\"sdp-transform\");\n/**\n * This function must be called with an SDP with 1 m=audio and 1 m=video\n * sections.\n */\nfunction extractRtpCapabilities({ sdpObject, }) {\n    // Map of RtpCodecParameters indexed by payload type.\n    const codecsMap = new Map();\n    // Array of RtpHeaderExtensions.\n    const headerExtensions = [];\n    // Whether a m=audio/video section has been already found.\n    let gotAudio = false;\n    let gotVideo = false;\n    for (const m of sdpObject.media) {\n        const kind = m.type;\n        switch (kind) {\n            case 'audio': {\n                if (gotAudio) {\n                    continue;\n                }\n                gotAudio = true;\n                break;\n            }\n            case 'video': {\n                if (gotVideo) {\n                    continue;\n                }\n                gotVideo = true;\n                break;\n            }\n            default: {\n                continue;\n            }\n        }\n        // Get codecs.\n        for (const rtp of m.rtp) {\n            const codec = {\n                kind: kind,\n                mimeType: `${kind}/${rtp.codec}`,\n                preferredPayloadType: rtp.payload,\n                clockRate: rtp.rate,\n                channels: rtp.encoding,\n                parameters: {},\n                rtcpFeedback: [],\n            };\n            codecsMap.set(codec.preferredPayloadType, codec);\n        }\n        // Get codec parameters.\n        for (const fmtp of m.fmtp ?? []) {\n            const parameters = sdpTransform.parseParams(fmtp.config);\n            const codec = codecsMap.get(fmtp.payload);\n            if (!codec) {\n                continue;\n            }\n            // Specials case to convert parameter value to string.\n            if (parameters?.hasOwnProperty('profile-level-id')) {\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\n            }\n            codec.parameters = parameters;\n        }\n        // Get RTCP feedback for each codec.\n        for (const fb of m.rtcpFb ?? []) {\n            const feedback = {\n                type: fb.type,\n                parameter: fb.subtype,\n            };\n            if (!feedback.parameter) {\n                delete feedback.parameter;\n            }\n            // rtcp-fb payload is not '*', so just apply it to its corresponding\n            // codec.\n            if (fb.payload !== '*') {\n                const codec = codecsMap.get(fb.payload);\n                if (!codec) {\n                    continue;\n                }\n                codec.rtcpFeedback.push(feedback);\n            }\n            // If rtcp-fb payload is '*' it must be applied to all codecs with same\n            // kind (with some exceptions such as RTX codec).\n            else {\n                for (const codec of codecsMap.values()) {\n                    if (codec.kind === kind && !/.+\\/rtx$/i.test(codec.mimeType)) {\n                        codec.rtcpFeedback.push(feedback);\n                    }\n                }\n            }\n        }\n        // Get RTP header extensions.\n        for (const ext of m.ext ?? []) {\n            // Ignore encrypted extensions (not yet supported in mediasoup).\n            if (ext['encrypt-uri']) {\n                continue;\n            }\n            const headerExtension = {\n                kind: kind,\n                uri: ext.uri,\n                preferredId: ext.value,\n            };\n            headerExtensions.push(headerExtension);\n        }\n    }\n    const rtpCapabilities = {\n        codecs: Array.from(codecsMap.values()),\n        headerExtensions: headerExtensions,\n    };\n    return rtpCapabilities;\n}\nfunction extractDtlsParameters({ sdpObject, }) {\n    let setup = sdpObject.setup;\n    let fingerprint = sdpObject.fingerprint;\n    if (!setup || !fingerprint) {\n        const mediaObject = (sdpObject.media ?? []).find((m) => m.port !== 0);\n        if (mediaObject) {\n            setup ??= mediaObject.setup;\n            fingerprint ??= mediaObject.fingerprint;\n        }\n    }\n    if (!setup) {\n        throw new Error('no a=setup found at SDP session or media level');\n    }\n    else if (!fingerprint) {\n        throw new Error('no a=fingerprint found at SDP session or media level');\n    }\n    let role;\n    switch (setup) {\n        case 'active': {\n            role = 'client';\n            break;\n        }\n        case 'passive': {\n            role = 'server';\n            break;\n        }\n        case 'actpass': {\n            role = 'auto';\n            break;\n        }\n    }\n    const dtlsParameters = {\n        role,\n        fingerprints: [\n            {\n                algorithm: fingerprint.type,\n                value: fingerprint.hash,\n            },\n        ],\n    };\n    return dtlsParameters;\n}\nfunction getCname({ offerMediaObject, }) {\n    const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine) {\n        return '';\n    }\n    return ssrcCnameLine.value;\n}\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject, }) {\n    for (const codec of offerRtpParameters.codecs) {\n        const mimeType = codec.mimeType.toLowerCase();\n        // Avoid parsing codec parameters for unhandled codecs.\n        if (mimeType !== 'audio/opus') {\n            continue;\n        }\n        const rtp = (answerMediaObject.rtp ?? []).find((r) => r.payload === codec.payloadType);\n        if (!rtp) {\n            continue;\n        }\n        // Just in case.\n        answerMediaObject.fmtp = answerMediaObject.fmtp ?? [];\n        let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);\n        if (!fmtp) {\n            fmtp = { payload: codec.payloadType, config: '' };\n            answerMediaObject.fmtp.push(fmtp);\n        }\n        const parameters = sdpTransform.parseParams(fmtp.config);\n        switch (mimeType) {\n            case 'audio/opus': {\n                const spropStereo = codec.parameters['sprop-stereo'];\n                if (spropStereo !== undefined) {\n                    parameters['stereo'] = Number(spropStereo) ? 1 : 0;\n                }\n                break;\n            }\n        }\n        // Write the codec fmtp.config back.\n        fmtp.config = '';\n        for (const key of Object.keys(parameters)) {\n            if (fmtp.config) {\n                fmtp.config += ';';\n            }\n            fmtp.config += `${key}=${parameters[key]}`;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}