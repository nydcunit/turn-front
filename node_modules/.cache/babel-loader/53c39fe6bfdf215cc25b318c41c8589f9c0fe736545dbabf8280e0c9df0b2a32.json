{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateRtpCapabilities = validateRtpCapabilities;\nexports.validateRtpParameters = validateRtpParameters;\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\nexports.validateSctpCapabilities = validateSctpCapabilities;\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\nexports.getSendingRtpParameters = getSendingRtpParameters;\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\nexports.reduceCodecs = reduceCodecs;\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\nexports.canSend = canSend;\nexports.canReceive = canReceive;\nconst h264 = require(\"h264-profile-level-id\");\nconst utils = require(\"./utils\");\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n  if (typeof caps !== 'object') {\n    throw new TypeError('caps is not an object');\n  }\n  // codecs is optional. If unset, fill with an empty array.\n  if (caps.codecs && !Array.isArray(caps.codecs)) {\n    throw new TypeError('caps.codecs is not an array');\n  } else if (!caps.codecs) {\n    caps.codecs = [];\n  }\n  for (const codec of caps.codecs) {\n    validateRtpCodecCapability(codec);\n  }\n  // headerExtensions is optional. If unset, fill with an empty array.\n  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {\n    throw new TypeError('caps.headerExtensions is not an array');\n  } else if (!caps.headerExtensions) {\n    caps.headerExtensions = [];\n  }\n  for (const ext of caps.headerExtensions) {\n    validateRtpHeaderExtension(ext);\n  }\n}\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n  if (typeof params !== 'object') {\n    throw new TypeError('params is not an object');\n  }\n  // mid is optional.\n  if (params.mid && typeof params.mid !== 'string') {\n    throw new TypeError('params.mid is not a string');\n  }\n  // codecs is mandatory.\n  if (!Array.isArray(params.codecs)) {\n    throw new TypeError('missing params.codecs');\n  }\n  for (const codec of params.codecs) {\n    validateRtpCodecParameters(codec);\n  }\n  // headerExtensions is optional. If unset, fill with an empty array.\n  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {\n    throw new TypeError('params.headerExtensions is not an array');\n  } else if (!params.headerExtensions) {\n    params.headerExtensions = [];\n  }\n  for (const ext of params.headerExtensions) {\n    validateRtpHeaderExtensionParameters(ext);\n  }\n  // encodings is optional. If unset, fill with an empty array.\n  if (params.encodings && !Array.isArray(params.encodings)) {\n    throw new TypeError('params.encodings is not an array');\n  } else if (!params.encodings) {\n    params.encodings = [];\n  }\n  for (const encoding of params.encodings) {\n    validateRtpEncodingParameters(encoding);\n  }\n  // rtcp is optional. If unset, fill with an empty object.\n  if (params.rtcp && typeof params.rtcp !== 'object') {\n    throw new TypeError('params.rtcp is not an object');\n  } else if (!params.rtcp) {\n    params.rtcp = {};\n  }\n  validateRtcpParameters(params.rtcp);\n}\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n  if (typeof params !== 'object') {\n    throw new TypeError('params is not an object');\n  }\n  // streamId is mandatory.\n  if (typeof params.streamId !== 'number') {\n    throw new TypeError('missing params.streamId');\n  }\n  // ordered is optional.\n  let orderedGiven = false;\n  if (typeof params.ordered === 'boolean') {\n    orderedGiven = true;\n  } else {\n    params.ordered = true;\n  }\n  // maxPacketLifeTime is optional.\n  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') {\n    throw new TypeError('invalid params.maxPacketLifeTime');\n  }\n  // maxRetransmits is optional.\n  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {\n    throw new TypeError('invalid params.maxRetransmits');\n  }\n  if (params.maxPacketLifeTime && params.maxRetransmits) {\n    throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n  }\n  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    params.ordered = false;\n  }\n  // label is optional.\n  if (params.label && typeof params.label !== 'string') {\n    throw new TypeError('invalid params.label');\n  }\n  // protocol is optional.\n  if (params.protocol && typeof params.protocol !== 'string') {\n    throw new TypeError('invalid params.protocol');\n  }\n}\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n  if (typeof caps !== 'object') {\n    throw new TypeError('caps is not an object');\n  }\n  // numStreams is mandatory.\n  if (!caps.numStreams || typeof caps.numStreams !== 'object') {\n    throw new TypeError('missing caps.numStreams');\n  }\n  validateNumSctpStreams(caps.numStreams);\n}\n/**\n * Generate extended RTP capabilities for sending and receiving.\n *\n * Resulting codecs keep order preferrred by local or remote capabilities\n * depending on `preferLocalCodecsOrder`.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {\n  const extendedRtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  };\n  // Match media codecs and keep the order preferred by local capabilities.\n  if (preferLocalCodecsOrder) {\n    for (const localCodec of localCaps.codecs ?? []) {\n      if (isRtxCodec(localCodec)) {\n        continue;\n      }\n      const matchingRemoteCodec = (remoteCaps.codecs ?? []).find(remoteCodec => matchCodecs(remoteCodec, localCodec, {\n        strict: true,\n        modify: true\n      }));\n      if (!matchingRemoteCodec) {\n        continue;\n      }\n      const extendedCodec = {\n        mimeType: localCodec.mimeType,\n        kind: localCodec.kind,\n        clockRate: localCodec.clockRate,\n        channels: localCodec.channels,\n        localPayloadType: localCodec.preferredPayloadType,\n        localRtxPayloadType: undefined,\n        remotePayloadType: matchingRemoteCodec.preferredPayloadType,\n        remoteRtxPayloadType: undefined,\n        localParameters: localCodec.parameters,\n        remoteParameters: matchingRemoteCodec.parameters,\n        rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec)\n      };\n      extendedRtpCapabilities.codecs.push(extendedCodec);\n    }\n  }\n  // Match media codecs and keep the order preferred by remote capabilities.\n  else {\n    for (const remoteCodec of remoteCaps.codecs ?? []) {\n      if (isRtxCodec(remoteCodec)) {\n        continue;\n      }\n      const matchingLocalCodec = (localCaps.codecs ?? []).find(localCodec => matchCodecs(localCodec, remoteCodec, {\n        strict: true,\n        modify: true\n      }));\n      if (!matchingLocalCodec) {\n        continue;\n      }\n      const extendedCodec = {\n        mimeType: matchingLocalCodec.mimeType,\n        kind: matchingLocalCodec.kind,\n        clockRate: matchingLocalCodec.clockRate,\n        channels: matchingLocalCodec.channels,\n        localPayloadType: matchingLocalCodec.preferredPayloadType,\n        localRtxPayloadType: undefined,\n        remotePayloadType: remoteCodec.preferredPayloadType,\n        remoteRtxPayloadType: undefined,\n        localParameters: matchingLocalCodec.parameters,\n        remoteParameters: remoteCodec.parameters,\n        rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n      };\n      extendedRtpCapabilities.codecs.push(extendedCodec);\n    }\n  }\n  // Match RTX codecs.\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    const matchingLocalRtxCodec = localCaps.codecs.find(localCodec => isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType);\n    const matchingRemoteRtxCodec = remoteCaps.codecs.find(remoteCodec => isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType);\n    if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n      extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n      extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n    }\n  }\n  // Match header extensions.\n  for (const remoteExt of remoteCaps.headerExtensions) {\n    const matchingLocalExt = localCaps.headerExtensions.find(localExt => matchHeaderExtensions(localExt, remoteExt));\n    if (!matchingLocalExt) {\n      continue;\n    }\n    const extendedExt = {\n      kind: remoteExt.kind,\n      uri: remoteExt.uri,\n      sendId: matchingLocalExt.preferredId,\n      recvId: remoteExt.preferredId,\n      encrypt: matchingLocalExt.preferredEncrypt,\n      direction: 'sendrecv'\n    };\n    switch (remoteExt.direction) {\n      case 'sendrecv':\n        {\n          extendedExt.direction = 'sendrecv';\n          break;\n        }\n      case 'recvonly':\n        {\n          extendedExt.direction = 'sendonly';\n          break;\n        }\n      case 'sendonly':\n        {\n          extendedExt.direction = 'recvonly';\n          break;\n        }\n      case 'inactive':\n        {\n          extendedExt.direction = 'inactive';\n          break;\n        }\n    }\n    extendedRtpCapabilities.headerExtensions.push(extendedExt);\n  }\n  return extendedRtpCapabilities;\n}\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n  const rtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  };\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      kind: extendedCodec.kind,\n      preferredPayloadType: extendedCodec.remotePayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.localParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpCapabilities.codecs.push(codec);\n    // Add RTX codec.\n    if (!extendedCodec.remoteRtxPayloadType) {\n      continue;\n    }\n    const rtxCodec = {\n      mimeType: `${extendedCodec.kind}/rtx`,\n      kind: extendedCodec.kind,\n      preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n      clockRate: extendedCodec.clockRate,\n      parameters: {\n        apt: extendedCodec.remotePayloadType\n      },\n      rtcpFeedback: []\n    };\n    rtpCapabilities.codecs.push(rtxCodec);\n    // TODO: In the future, we need to add FEC, CN, etc, codecs.\n  }\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions not valid for receiving.\n    if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {\n      continue;\n    }\n    const ext = {\n      kind: extendedExtension.kind,\n      uri: extendedExtension.uri,\n      preferredId: extendedExtension.recvId,\n      preferredEncrypt: extendedExtension.encrypt,\n      direction: extendedExtension.direction\n    };\n    rtpCapabilities.headerExtensions.push(ext);\n  }\n  return rtpCapabilities;\n}\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n  const rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    if (extendedCodec.kind !== kind) {\n      continue;\n    }\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      payloadType: extendedCodec.localPayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.localParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpParameters.codecs.push(codec);\n    // Add RTX codec.\n    if (extendedCodec.localRtxPayloadType) {\n      const rtxCodec = {\n        mimeType: `${extendedCodec.kind}/rtx`,\n        payloadType: extendedCodec.localRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.localPayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpParameters.codecs.push(rtxCodec);\n    }\n  }\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions of a different kind and those not valid for sending.\n    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n      continue;\n    }\n    const ext = {\n      uri: extendedExtension.uri,\n      id: extendedExtension.sendId,\n      encrypt: extendedExtension.encrypt,\n      parameters: {}\n    };\n    rtpParameters.headerExtensions.push(ext);\n  }\n  return rtpParameters;\n}\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n  const rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    if (extendedCodec.kind !== kind) {\n      continue;\n    }\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      payloadType: extendedCodec.localPayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.remoteParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpParameters.codecs.push(codec);\n    // Add RTX codec.\n    if (extendedCodec.localRtxPayloadType) {\n      const rtxCodec = {\n        mimeType: `${extendedCodec.kind}/rtx`,\n        payloadType: extendedCodec.localRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.localPayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpParameters.codecs.push(rtxCodec);\n    }\n  }\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions of a different kind and those not valid for sending.\n    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n      continue;\n    }\n    const ext = {\n      uri: extendedExtension.uri,\n      id: extendedExtension.sendId,\n      encrypt: extendedExtension.encrypt,\n      parameters: {}\n    };\n    rtpParameters.headerExtensions.push(ext);\n  }\n  // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n  if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter(fb => fb.type !== 'goog-remb');\n    }\n  } else if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter(fb => fb.type !== 'transport-cc');\n    }\n  } else {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter(fb => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');\n    }\n  }\n  return rtpParameters;\n}\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n  const filteredCodecs = [];\n  // If no capability codec is given, take the first one (and RTX).\n  if (!capCodec) {\n    filteredCodecs.push(codecs[0]);\n    if (isRtxCodec(codecs[1])) {\n      filteredCodecs.push(codecs[1]);\n    }\n  }\n  // Otherwise look for a compatible set of codecs.\n  else {\n    for (let idx = 0; idx < codecs.length; ++idx) {\n      if (matchCodecs(codecs[idx], capCodec, {\n        strict: true\n      })) {\n        filteredCodecs.push(codecs[idx]);\n        if (isRtxCodec(codecs[idx + 1])) {\n          filteredCodecs.push(codecs[idx + 1]);\n        }\n        break;\n      }\n    }\n    if (filteredCodecs.length === 0) {\n      throw new TypeError('no matching codec found');\n    }\n  }\n  return filteredCodecs;\n}\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n  // Clone given reference video RTP parameters.\n  videoRtpParameters = utils.clone(videoRtpParameters);\n  // This may throw.\n  validateRtpParameters(videoRtpParameters);\n  const rtpParameters = {\n    mid: RTP_PROBATOR_MID,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [{\n      ssrc: RTP_PROBATOR_SSRC\n    }],\n    rtcp: {\n      cname: 'probator'\n    }\n  };\n  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n  return rtpParameters;\n}\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n  return extendedRtpCapabilities.codecs.some(codec => codec.kind === kind);\n}\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n  // This may throw.\n  validateRtpParameters(rtpParameters);\n  if (rtpParameters.codecs.length === 0) {\n    return false;\n  }\n  const firstMediaCodec = rtpParameters.codecs[0];\n  return extendedRtpCapabilities.codecs.some(codec => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n  const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (typeof codec !== 'object') {\n    throw new TypeError('codec is not an object');\n  }\n  // mimeType is mandatory.\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n    throw new TypeError('missing codec.mimeType');\n  }\n  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) {\n    throw new TypeError('invalid codec.mimeType');\n  }\n  // Just override kind with media component of mimeType.\n  codec.kind = mimeTypeMatch[1].toLowerCase();\n  // preferredPayloadType is optional.\n  if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') {\n    throw new TypeError('invalid codec.preferredPayloadType');\n  }\n  // clockRate is mandatory.\n  if (typeof codec.clockRate !== 'number') {\n    throw new TypeError('missing codec.clockRate');\n  }\n  // channels is optional. If unset, set it to 1 (just if audio).\n  if (codec.kind === 'audio') {\n    if (typeof codec.channels !== 'number') {\n      codec.channels = 1;\n    }\n  } else {\n    delete codec.channels;\n  }\n  // parameters is optional. If unset, set it to an empty object.\n  if (!codec.parameters || typeof codec.parameters !== 'object') {\n    codec.parameters = {};\n  }\n  for (const key of Object.keys(codec.parameters)) {\n    let value = codec.parameters[key];\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n    }\n    // Specific parameters validation.\n    if (key === 'apt') {\n      if (typeof value !== 'number') {\n        throw new TypeError('invalid codec apt parameter');\n      }\n    }\n  }\n  // rtcpFeedback is optional. If unset, set it to an empty array.\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n    codec.rtcpFeedback = [];\n  }\n  for (const fb of codec.rtcpFeedback) {\n    validateRtcpFeedback(fb);\n  }\n}\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n  if (typeof fb !== 'object') {\n    throw new TypeError('fb is not an object');\n  }\n  // type is mandatory.\n  if (!fb.type || typeof fb.type !== 'string') {\n    throw new TypeError('missing fb.type');\n  }\n  // parameter is optional. If unset set it to an empty string.\n  if (!fb.parameter || typeof fb.parameter !== 'string') {\n    fb.parameter = '';\n  }\n}\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n  if (typeof ext !== 'object') {\n    throw new TypeError('ext is not an object');\n  }\n  // kind is mandatory.\n  if (ext.kind !== 'audio' && ext.kind !== 'video') {\n    throw new TypeError('invalid ext.kind');\n  }\n  // uri is mandatory.\n  if (!ext.uri || typeof ext.uri !== 'string') {\n    throw new TypeError('missing ext.uri');\n  }\n  // preferredId is mandatory.\n  if (typeof ext.preferredId !== 'number') {\n    throw new TypeError('missing ext.preferredId');\n  }\n  // preferredEncrypt is optional. If unset set it to false.\n  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {\n    throw new TypeError('invalid ext.preferredEncrypt');\n  } else if (!ext.preferredEncrypt) {\n    ext.preferredEncrypt = false;\n  }\n  // direction is optional. If unset set it to sendrecv.\n  if (ext.direction && typeof ext.direction !== 'string') {\n    throw new TypeError('invalid ext.direction');\n  } else if (!ext.direction) {\n    ext.direction = 'sendrecv';\n  }\n}\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n  const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (typeof codec !== 'object') {\n    throw new TypeError('codec is not an object');\n  }\n  // mimeType is mandatory.\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n    throw new TypeError('missing codec.mimeType');\n  }\n  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) {\n    throw new TypeError('invalid codec.mimeType');\n  }\n  // payloadType is mandatory.\n  if (typeof codec.payloadType !== 'number') {\n    throw new TypeError('missing codec.payloadType');\n  }\n  // clockRate is mandatory.\n  if (typeof codec.clockRate !== 'number') {\n    throw new TypeError('missing codec.clockRate');\n  }\n  const kind = mimeTypeMatch[1].toLowerCase();\n  // channels is optional. If unset, set it to 1 (just if audio).\n  if (kind === 'audio') {\n    if (typeof codec.channels !== 'number') {\n      codec.channels = 1;\n    }\n  } else {\n    delete codec.channels;\n  }\n  // parameters is optional. If unset, set it to an empty object.\n  if (!codec.parameters || typeof codec.parameters !== 'object') {\n    codec.parameters = {};\n  }\n  for (const key of Object.keys(codec.parameters)) {\n    let value = codec.parameters[key];\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n    }\n    // Specific parameters validation.\n    if (key === 'apt') {\n      if (typeof value !== 'number') {\n        throw new TypeError('invalid codec apt parameter');\n      }\n    }\n  }\n  // rtcpFeedback is optional. If unset, set it to an empty array.\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n    codec.rtcpFeedback = [];\n  }\n  for (const fb of codec.rtcpFeedback) {\n    validateRtcpFeedback(fb);\n  }\n}\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n  if (typeof ext !== 'object') {\n    throw new TypeError('ext is not an object');\n  }\n  // uri is mandatory.\n  if (!ext.uri || typeof ext.uri !== 'string') {\n    throw new TypeError('missing ext.uri');\n  }\n  // id is mandatory.\n  if (typeof ext.id !== 'number') {\n    throw new TypeError('missing ext.id');\n  }\n  // encrypt is optional. If unset set it to false.\n  if (ext.encrypt && typeof ext.encrypt !== 'boolean') {\n    throw new TypeError('invalid ext.encrypt');\n  } else if (!ext.encrypt) {\n    ext.encrypt = false;\n  }\n  // parameters is optional. If unset, set it to an empty object.\n  if (!ext.parameters || typeof ext.parameters !== 'object') {\n    ext.parameters = {};\n  }\n  for (const key of Object.keys(ext.parameters)) {\n    let value = ext.parameters[key];\n    if (value === undefined) {\n      ext.parameters[key] = '';\n      value = '';\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError('invalid header extension parameter');\n    }\n  }\n}\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n  if (typeof encoding !== 'object') {\n    throw new TypeError('encoding is not an object');\n  }\n  // ssrc is optional.\n  if (encoding.ssrc && typeof encoding.ssrc !== 'number') {\n    throw new TypeError('invalid encoding.ssrc');\n  }\n  // rid is optional.\n  if (encoding.rid && typeof encoding.rid !== 'string') {\n    throw new TypeError('invalid encoding.rid');\n  }\n  // rtx is optional.\n  if (encoding.rtx && typeof encoding.rtx !== 'object') {\n    throw new TypeError('invalid encoding.rtx');\n  } else if (encoding.rtx) {\n    // RTX ssrc is mandatory if rtx is present.\n    if (typeof encoding.rtx.ssrc !== 'number') {\n      throw new TypeError('missing encoding.rtx.ssrc');\n    }\n  }\n  // dtx is optional. If unset set it to false.\n  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {\n    encoding.dtx = false;\n  }\n  // scalabilityMode is optional.\n  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') {\n    throw new TypeError('invalid encoding.scalabilityMode');\n  }\n}\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n  if (typeof rtcp !== 'object') {\n    throw new TypeError('rtcp is not an object');\n  }\n  // cname is optional.\n  if (rtcp.cname && typeof rtcp.cname !== 'string') {\n    throw new TypeError('invalid rtcp.cname');\n  }\n  // reducedSize is optional. If unset set it to true.\n  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {\n    rtcp.reducedSize = true;\n  }\n}\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n  if (typeof numStreams !== 'object') {\n    throw new TypeError('numStreams is not an object');\n  }\n  // OS is mandatory.\n  if (typeof numStreams.OS !== 'number') {\n    throw new TypeError('missing numStreams.OS');\n  }\n  // MIS is mandatory.\n  if (typeof numStreams.MIS !== 'number') {\n    throw new TypeError('missing numStreams.MIS');\n  }\n}\nfunction isRtxCodec(codec) {\n  if (!codec) {\n    return false;\n  }\n  return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec, {\n  strict = false,\n  modify = false\n} = {}) {\n  const aMimeType = aCodec.mimeType.toLowerCase();\n  const bMimeType = bCodec.mimeType.toLowerCase();\n  if (aMimeType !== bMimeType) {\n    return false;\n  }\n  if (aCodec.clockRate !== bCodec.clockRate) {\n    return false;\n  }\n  if (aCodec.channels !== bCodec.channels) {\n    return false;\n  }\n  // Per codec special checks.\n  switch (aMimeType) {\n    case 'video/h264':\n      {\n        if (strict) {\n          const aPacketizationMode = aCodec.parameters['packetization-mode'] ?? 0;\n          const bPacketizationMode = bCodec.parameters['packetization-mode'] ?? 0;\n          if (aPacketizationMode !== bPacketizationMode) {\n            return false;\n          }\n          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {\n            return false;\n          }\n          let selectedProfileLevelId;\n          try {\n            selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);\n          } catch (error) {\n            return false;\n          }\n          if (modify) {\n            if (selectedProfileLevelId) {\n              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n            } else {\n              delete aCodec.parameters['profile-level-id'];\n              delete bCodec.parameters['profile-level-id'];\n            }\n          }\n        }\n        break;\n      }\n    case 'video/vp9':\n      {\n        if (strict) {\n          const aProfileId = aCodec.parameters['profile-id'] ?? 0;\n          const bProfileId = bCodec.parameters['profile-id'] ?? 0;\n          if (aProfileId !== bProfileId) {\n            return false;\n          }\n        }\n        break;\n      }\n  }\n  return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {\n    return false;\n  }\n  if (aExt.uri !== bExt.uri) {\n    return false;\n  }\n  return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n  const reducedRtcpFeedback = [];\n  for (const aFb of codecA.rtcpFeedback ?? []) {\n    const matchingBFb = (codecB.rtcpFeedback ?? []).find(bFb => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));\n    if (matchingBFb) {\n      reducedRtcpFeedback.push(matchingBFb);\n    }\n  }\n  return reducedRtcpFeedback;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","validateRtpCapabilities","validateRtpParameters","validateSctpStreamParameters","validateSctpCapabilities","getExtendedRtpCapabilities","getRecvRtpCapabilities","getSendingRtpParameters","getSendingRemoteRtpParameters","reduceCodecs","generateProbatorRtpParameters","canSend","canReceive","h264","require","utils","RTP_PROBATOR_MID","RTP_PROBATOR_SSRC","RTP_PROBATOR_CODEC_PAYLOAD_TYPE","caps","TypeError","codecs","Array","isArray","codec","validateRtpCodecCapability","headerExtensions","ext","validateRtpHeaderExtension","params","mid","validateRtpCodecParameters","validateRtpHeaderExtensionParameters","encodings","encoding","validateRtpEncodingParameters","rtcp","validateRtcpParameters","streamId","orderedGiven","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","numStreams","validateNumSctpStreams","localCaps","remoteCaps","preferLocalCodecsOrder","extendedRtpCapabilities","localCodec","isRtxCodec","matchingRemoteCodec","find","remoteCodec","matchCodecs","strict","modify","extendedCodec","mimeType","kind","clockRate","channels","localPayloadType","preferredPayloadType","localRtxPayloadType","undefined","remotePayloadType","remoteRtxPayloadType","localParameters","parameters","remoteParameters","rtcpFeedback","reduceRtcpFeedback","push","matchingLocalCodec","matchingLocalRtxCodec","apt","matchingRemoteRtxCodec","remoteExt","matchingLocalExt","localExt","matchHeaderExtensions","extendedExt","uri","sendId","preferredId","recvId","encrypt","preferredEncrypt","direction","rtpCapabilities","rtxCodec","extendedExtension","rtpParameters","payloadType","id","some","filter","fb","type","capCodec","filteredCodecs","idx","length","videoRtpParameters","clone","ssrc","cname","firstMediaCodec","MimeTypeRegex","RegExp","mimeTypeMatch","exec","toLowerCase","key","keys","validateRtcpFeedback","parameter","rid","rtx","dtx","scalabilityMode","reducedSize","OS","MIS","test","aCodec","bCodec","aMimeType","bMimeType","aPacketizationMode","bPacketizationMode","isSameProfile","selectedProfileLevelId","generateProfileLevelIdStringForAnswer","error","aProfileId","bProfileId","aExt","bExt","codecA","codecB","reducedRtcpFeedback","aFb","matchingBFb","bFb"],"sources":["/Users/user/turn/turn-front/node_modules/mediasoup-client/lib/ortc.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateRtpCapabilities = validateRtpCapabilities;\nexports.validateRtpParameters = validateRtpParameters;\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\nexports.validateSctpCapabilities = validateSctpCapabilities;\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\nexports.getSendingRtpParameters = getSendingRtpParameters;\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\nexports.reduceCodecs = reduceCodecs;\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\nexports.canSend = canSend;\nexports.canReceive = canReceive;\nconst h264 = require(\"h264-profile-level-id\");\nconst utils = require(\"./utils\");\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n    if (typeof caps !== 'object') {\n        throw new TypeError('caps is not an object');\n    }\n    // codecs is optional. If unset, fill with an empty array.\n    if (caps.codecs && !Array.isArray(caps.codecs)) {\n        throw new TypeError('caps.codecs is not an array');\n    }\n    else if (!caps.codecs) {\n        caps.codecs = [];\n    }\n    for (const codec of caps.codecs) {\n        validateRtpCodecCapability(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {\n        throw new TypeError('caps.headerExtensions is not an array');\n    }\n    else if (!caps.headerExtensions) {\n        caps.headerExtensions = [];\n    }\n    for (const ext of caps.headerExtensions) {\n        validateRtpHeaderExtension(ext);\n    }\n}\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // mid is optional.\n    if (params.mid && typeof params.mid !== 'string') {\n        throw new TypeError('params.mid is not a string');\n    }\n    // codecs is mandatory.\n    if (!Array.isArray(params.codecs)) {\n        throw new TypeError('missing params.codecs');\n    }\n    for (const codec of params.codecs) {\n        validateRtpCodecParameters(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {\n        throw new TypeError('params.headerExtensions is not an array');\n    }\n    else if (!params.headerExtensions) {\n        params.headerExtensions = [];\n    }\n    for (const ext of params.headerExtensions) {\n        validateRtpHeaderExtensionParameters(ext);\n    }\n    // encodings is optional. If unset, fill with an empty array.\n    if (params.encodings && !Array.isArray(params.encodings)) {\n        throw new TypeError('params.encodings is not an array');\n    }\n    else if (!params.encodings) {\n        params.encodings = [];\n    }\n    for (const encoding of params.encodings) {\n        validateRtpEncodingParameters(encoding);\n    }\n    // rtcp is optional. If unset, fill with an empty object.\n    if (params.rtcp && typeof params.rtcp !== 'object') {\n        throw new TypeError('params.rtcp is not an object');\n    }\n    else if (!params.rtcp) {\n        params.rtcp = {};\n    }\n    validateRtcpParameters(params.rtcp);\n}\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // streamId is mandatory.\n    if (typeof params.streamId !== 'number') {\n        throw new TypeError('missing params.streamId');\n    }\n    // ordered is optional.\n    let orderedGiven = false;\n    if (typeof params.ordered === 'boolean') {\n        orderedGiven = true;\n    }\n    else {\n        params.ordered = true;\n    }\n    // maxPacketLifeTime is optional.\n    if (params.maxPacketLifeTime &&\n        typeof params.maxPacketLifeTime !== 'number') {\n        throw new TypeError('invalid params.maxPacketLifeTime');\n    }\n    // maxRetransmits is optional.\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {\n        throw new TypeError('invalid params.maxRetransmits');\n    }\n    if (params.maxPacketLifeTime && params.maxRetransmits) {\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n    }\n    if (orderedGiven &&\n        params.ordered &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n    }\n    else if (!orderedGiven &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        params.ordered = false;\n    }\n    // label is optional.\n    if (params.label && typeof params.label !== 'string') {\n        throw new TypeError('invalid params.label');\n    }\n    // protocol is optional.\n    if (params.protocol && typeof params.protocol !== 'string') {\n        throw new TypeError('invalid params.protocol');\n    }\n}\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n    if (typeof caps !== 'object') {\n        throw new TypeError('caps is not an object');\n    }\n    // numStreams is mandatory.\n    if (!caps.numStreams || typeof caps.numStreams !== 'object') {\n        throw new TypeError('missing caps.numStreams');\n    }\n    validateNumSctpStreams(caps.numStreams);\n}\n/**\n * Generate extended RTP capabilities for sending and receiving.\n *\n * Resulting codecs keep order preferrred by local or remote capabilities\n * depending on `preferLocalCodecsOrder`.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {\n    const extendedRtpCapabilities = {\n        codecs: [],\n        headerExtensions: [],\n    };\n    // Match media codecs and keep the order preferred by local capabilities.\n    if (preferLocalCodecsOrder) {\n        for (const localCodec of localCaps.codecs ?? []) {\n            if (isRtxCodec(localCodec)) {\n                continue;\n            }\n            const matchingRemoteCodec = (remoteCaps.codecs ?? []).find((remoteCodec) => matchCodecs(remoteCodec, localCodec, { strict: true, modify: true }));\n            if (!matchingRemoteCodec) {\n                continue;\n            }\n            const extendedCodec = {\n                mimeType: localCodec.mimeType,\n                kind: localCodec.kind,\n                clockRate: localCodec.clockRate,\n                channels: localCodec.channels,\n                localPayloadType: localCodec.preferredPayloadType,\n                localRtxPayloadType: undefined,\n                remotePayloadType: matchingRemoteCodec.preferredPayloadType,\n                remoteRtxPayloadType: undefined,\n                localParameters: localCodec.parameters,\n                remoteParameters: matchingRemoteCodec.parameters,\n                rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec),\n            };\n            extendedRtpCapabilities.codecs.push(extendedCodec);\n        }\n    }\n    // Match media codecs and keep the order preferred by remote capabilities.\n    else {\n        for (const remoteCodec of remoteCaps.codecs ?? []) {\n            if (isRtxCodec(remoteCodec)) {\n                continue;\n            }\n            const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));\n            if (!matchingLocalCodec) {\n                continue;\n            }\n            const extendedCodec = {\n                mimeType: matchingLocalCodec.mimeType,\n                kind: matchingLocalCodec.kind,\n                clockRate: matchingLocalCodec.clockRate,\n                channels: matchingLocalCodec.channels,\n                localPayloadType: matchingLocalCodec.preferredPayloadType,\n                localRtxPayloadType: undefined,\n                remotePayloadType: remoteCodec.preferredPayloadType,\n                remoteRtxPayloadType: undefined,\n                localParameters: matchingLocalCodec.parameters,\n                remoteParameters: remoteCodec.parameters,\n                rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),\n            };\n            extendedRtpCapabilities.codecs.push(extendedCodec);\n        }\n    }\n    // Match RTX codecs.\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) &&\n            localCodec.parameters.apt === extendedCodec.localPayloadType);\n        const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) &&\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType);\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n            extendedCodec.localRtxPayloadType =\n                matchingLocalRtxCodec.preferredPayloadType;\n            extendedCodec.remoteRtxPayloadType =\n                matchingRemoteRtxCodec.preferredPayloadType;\n        }\n    }\n    // Match header extensions.\n    for (const remoteExt of remoteCaps.headerExtensions) {\n        const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));\n        if (!matchingLocalExt) {\n            continue;\n        }\n        const extendedExt = {\n            kind: remoteExt.kind,\n            uri: remoteExt.uri,\n            sendId: matchingLocalExt.preferredId,\n            recvId: remoteExt.preferredId,\n            encrypt: matchingLocalExt.preferredEncrypt,\n            direction: 'sendrecv',\n        };\n        switch (remoteExt.direction) {\n            case 'sendrecv': {\n                extendedExt.direction = 'sendrecv';\n                break;\n            }\n            case 'recvonly': {\n                extendedExt.direction = 'sendonly';\n                break;\n            }\n            case 'sendonly': {\n                extendedExt.direction = 'recvonly';\n                break;\n            }\n            case 'inactive': {\n                extendedExt.direction = 'inactive';\n                break;\n            }\n        }\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    }\n    return extendedRtpCapabilities;\n}\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n    const rtpCapabilities = {\n        codecs: [],\n        headerExtensions: [],\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remotePayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback,\n        };\n        rtpCapabilities.codecs.push(codec);\n        // Add RTX codec.\n        if (!extendedCodec.remoteRtxPayloadType) {\n            continue;\n        }\n        const rtxCodec = {\n            mimeType: `${extendedCodec.kind}/rtx`,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n            clockRate: extendedCodec.clockRate,\n            parameters: {\n                apt: extendedCodec.remotePayloadType,\n            },\n            rtcpFeedback: [],\n        };\n        rtpCapabilities.codecs.push(rtxCodec);\n        // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions not valid for receiving.\n        if (extendedExtension.direction !== 'sendrecv' &&\n            extendedExtension.direction !== 'recvonly') {\n            continue;\n        }\n        const ext = {\n            kind: extendedExtension.kind,\n            uri: extendedExtension.uri,\n            preferredId: extendedExtension.recvId,\n            preferredEncrypt: extendedExtension.encrypt,\n            direction: extendedExtension.direction,\n        };\n        rtpCapabilities.headerExtensions.push(ext);\n    }\n    return rtpCapabilities;\n}\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {},\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind) {\n            continue;\n        }\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback,\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType,\n                },\n                rtcpFeedback: [],\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {},\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    return rtpParameters;\n}\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {},\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind) {\n            continue;\n        }\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.remoteParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback,\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType,\n                },\n                rtcpFeedback: [],\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {},\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n    if (rtpParameters.headerExtensions.some(ext => ext.uri ===\n        'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'goog-remb');\n        }\n    }\n    else if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter(fb => fb.type !== 'transport-cc');\n        }\n    }\n    else {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');\n        }\n    }\n    return rtpParameters;\n}\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n    const filteredCodecs = [];\n    // If no capability codec is given, take the first one (and RTX).\n    if (!capCodec) {\n        filteredCodecs.push(codecs[0]);\n        if (isRtxCodec(codecs[1])) {\n            filteredCodecs.push(codecs[1]);\n        }\n    }\n    // Otherwise look for a compatible set of codecs.\n    else {\n        for (let idx = 0; idx < codecs.length; ++idx) {\n            if (matchCodecs(codecs[idx], capCodec, { strict: true })) {\n                filteredCodecs.push(codecs[idx]);\n                if (isRtxCodec(codecs[idx + 1])) {\n                    filteredCodecs.push(codecs[idx + 1]);\n                }\n                break;\n            }\n        }\n        if (filteredCodecs.length === 0) {\n            throw new TypeError('no matching codec found');\n        }\n    }\n    return filteredCodecs;\n}\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n    // Clone given reference video RTP parameters.\n    videoRtpParameters = utils.clone(videoRtpParameters);\n    // This may throw.\n    validateRtpParameters(videoRtpParameters);\n    const rtpParameters = {\n        mid: RTP_PROBATOR_MID,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\n        rtcp: { cname: 'probator' },\n    };\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n    return rtpParameters;\n}\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n    return extendedRtpCapabilities.codecs.some((codec) => codec.kind === kind);\n}\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n    // This may throw.\n    validateRtpParameters(rtpParameters);\n    if (rtpParameters.codecs.length === 0) {\n        return false;\n    }\n    const firstMediaCodec = rtpParameters.codecs[0];\n    return extendedRtpCapabilities.codecs.some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object') {\n        throw new TypeError('codec is not an object');\n    }\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n        throw new TypeError('missing codec.mimeType');\n    }\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch) {\n        throw new TypeError('invalid codec.mimeType');\n    }\n    // Just override kind with media component of mimeType.\n    codec.kind = mimeTypeMatch[1].toLowerCase();\n    // preferredPayloadType is optional.\n    if (codec.preferredPayloadType &&\n        typeof codec.preferredPayloadType !== 'number') {\n        throw new TypeError('invalid codec.preferredPayloadType');\n    }\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number') {\n        throw new TypeError('missing codec.clockRate');\n    }\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (codec.kind === 'audio') {\n        if (typeof codec.channels !== 'number') {\n            codec.channels = 1;\n        }\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object') {\n        codec.parameters = {};\n    }\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number') {\n                throw new TypeError('invalid codec apt parameter');\n            }\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n        codec.rtcpFeedback = [];\n    }\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n    if (typeof fb !== 'object') {\n        throw new TypeError('fb is not an object');\n    }\n    // type is mandatory.\n    if (!fb.type || typeof fb.type !== 'string') {\n        throw new TypeError('missing fb.type');\n    }\n    // parameter is optional. If unset set it to an empty string.\n    if (!fb.parameter || typeof fb.parameter !== 'string') {\n        fb.parameter = '';\n    }\n}\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n    if (typeof ext !== 'object') {\n        throw new TypeError('ext is not an object');\n    }\n    // kind is mandatory.\n    if (ext.kind !== 'audio' && ext.kind !== 'video') {\n        throw new TypeError('invalid ext.kind');\n    }\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string') {\n        throw new TypeError('missing ext.uri');\n    }\n    // preferredId is mandatory.\n    if (typeof ext.preferredId !== 'number') {\n        throw new TypeError('missing ext.preferredId');\n    }\n    // preferredEncrypt is optional. If unset set it to false.\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {\n        throw new TypeError('invalid ext.preferredEncrypt');\n    }\n    else if (!ext.preferredEncrypt) {\n        ext.preferredEncrypt = false;\n    }\n    // direction is optional. If unset set it to sendrecv.\n    if (ext.direction && typeof ext.direction !== 'string') {\n        throw new TypeError('invalid ext.direction');\n    }\n    else if (!ext.direction) {\n        ext.direction = 'sendrecv';\n    }\n}\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object') {\n        throw new TypeError('codec is not an object');\n    }\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n        throw new TypeError('missing codec.mimeType');\n    }\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch) {\n        throw new TypeError('invalid codec.mimeType');\n    }\n    // payloadType is mandatory.\n    if (typeof codec.payloadType !== 'number') {\n        throw new TypeError('missing codec.payloadType');\n    }\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number') {\n        throw new TypeError('missing codec.clockRate');\n    }\n    const kind = mimeTypeMatch[1].toLowerCase();\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (kind === 'audio') {\n        if (typeof codec.channels !== 'number') {\n            codec.channels = 1;\n        }\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object') {\n        codec.parameters = {};\n    }\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number') {\n                throw new TypeError('invalid codec apt parameter');\n            }\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n        codec.rtcpFeedback = [];\n    }\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n    if (typeof ext !== 'object') {\n        throw new TypeError('ext is not an object');\n    }\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string') {\n        throw new TypeError('missing ext.uri');\n    }\n    // id is mandatory.\n    if (typeof ext.id !== 'number') {\n        throw new TypeError('missing ext.id');\n    }\n    // encrypt is optional. If unset set it to false.\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean') {\n        throw new TypeError('invalid ext.encrypt');\n    }\n    else if (!ext.encrypt) {\n        ext.encrypt = false;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!ext.parameters || typeof ext.parameters !== 'object') {\n        ext.parameters = {};\n    }\n    for (const key of Object.keys(ext.parameters)) {\n        let value = ext.parameters[key];\n        if (value === undefined) {\n            ext.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError('invalid header extension parameter');\n        }\n    }\n}\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n    if (typeof encoding !== 'object') {\n        throw new TypeError('encoding is not an object');\n    }\n    // ssrc is optional.\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number') {\n        throw new TypeError('invalid encoding.ssrc');\n    }\n    // rid is optional.\n    if (encoding.rid && typeof encoding.rid !== 'string') {\n        throw new TypeError('invalid encoding.rid');\n    }\n    // rtx is optional.\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\n        throw new TypeError('invalid encoding.rtx');\n    }\n    else if (encoding.rtx) {\n        // RTX ssrc is mandatory if rtx is present.\n        if (typeof encoding.rtx.ssrc !== 'number') {\n            throw new TypeError('missing encoding.rtx.ssrc');\n        }\n    }\n    // dtx is optional. If unset set it to false.\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {\n        encoding.dtx = false;\n    }\n    // scalabilityMode is optional.\n    if (encoding.scalabilityMode &&\n        typeof encoding.scalabilityMode !== 'string') {\n        throw new TypeError('invalid encoding.scalabilityMode');\n    }\n}\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n    if (typeof rtcp !== 'object') {\n        throw new TypeError('rtcp is not an object');\n    }\n    // cname is optional.\n    if (rtcp.cname && typeof rtcp.cname !== 'string') {\n        throw new TypeError('invalid rtcp.cname');\n    }\n    // reducedSize is optional. If unset set it to true.\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {\n        rtcp.reducedSize = true;\n    }\n}\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n    if (typeof numStreams !== 'object') {\n        throw new TypeError('numStreams is not an object');\n    }\n    // OS is mandatory.\n    if (typeof numStreams.OS !== 'number') {\n        throw new TypeError('missing numStreams.OS');\n    }\n    // MIS is mandatory.\n    if (typeof numStreams.MIS !== 'number') {\n        throw new TypeError('missing numStreams.MIS');\n    }\n}\nfunction isRtxCodec(codec) {\n    if (!codec) {\n        return false;\n    }\n    return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\n    const aMimeType = aCodec.mimeType.toLowerCase();\n    const bMimeType = bCodec.mimeType.toLowerCase();\n    if (aMimeType !== bMimeType) {\n        return false;\n    }\n    if (aCodec.clockRate !== bCodec.clockRate) {\n        return false;\n    }\n    if (aCodec.channels !== bCodec.channels) {\n        return false;\n    }\n    // Per codec special checks.\n    switch (aMimeType) {\n        case 'video/h264': {\n            if (strict) {\n                const aPacketizationMode = aCodec.parameters['packetization-mode'] ?? 0;\n                const bPacketizationMode = bCodec.parameters['packetization-mode'] ?? 0;\n                if (aPacketizationMode !== bPacketizationMode) {\n                    return false;\n                }\n                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {\n                    return false;\n                }\n                let selectedProfileLevelId;\n                try {\n                    selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);\n                }\n                catch (error) {\n                    return false;\n                }\n                if (modify) {\n                    if (selectedProfileLevelId) {\n                        aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                        bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                    }\n                    else {\n                        delete aCodec.parameters['profile-level-id'];\n                        delete bCodec.parameters['profile-level-id'];\n                    }\n                }\n            }\n            break;\n        }\n        case 'video/vp9': {\n            if (strict) {\n                const aProfileId = aCodec.parameters['profile-id'] ?? 0;\n                const bProfileId = bCodec.parameters['profile-id'] ?? 0;\n                if (aProfileId !== bProfileId) {\n                    return false;\n                }\n            }\n            break;\n        }\n    }\n    return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {\n        return false;\n    }\n    if (aExt.uri !== bExt.uri) {\n        return false;\n    }\n    return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n    const reducedRtcpFeedback = [];\n    for (const aFb of codecA.rtcpFeedback ?? []) {\n        const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type &&\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter)));\n        if (matchingBFb) {\n            reducedRtcpFeedback.push(matchingBFb);\n        }\n    }\n    return reducedRtcpFeedback;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}