{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwaitQueue = void 0;\nconst Logger_1 = require(\"./Logger\");\nconst errors_1 = require(\"./errors\");\nconst logger = new Logger_1.Logger('AwaitQueue');\nclass AwaitQueue {\n  // Queue of pending tasks (map of PendingTasks indexed by id).\n  pendingTasks = new Map();\n  // Incrementing PendingTask id.\n  nextTaskId = 0;\n  // Whether stop() method is stopping all pending tasks.\n  stopping = false;\n  constructor() {\n    logger.debug('constructor()');\n  }\n  get size() {\n    return this.pendingTasks.size;\n  }\n  async push(task, name) {\n    name = name ?? task.name;\n    logger.debug(`push() [name:${name}]`);\n    if (typeof task !== 'function') {\n      throw new TypeError('given task is not a function');\n    }\n    if (name) {\n      try {\n        Object.defineProperty(task, 'name', {\n          value: name\n        });\n      } catch (error) {}\n    }\n    return new Promise((resolve, reject) => {\n      const pendingTask = {\n        id: this.nextTaskId++,\n        task: task,\n        name: name,\n        enqueuedAt: Date.now(),\n        executedAt: undefined,\n        completed: false,\n        resolve: result => {\n          // pendingTask.resolve() can only be called in execute() method. Since\n          // resolve() was called it means that the task successfully completed.\n          // However the task may have been stopped before it completed (via\n          // stop() or remove()) so its completed flag was already set. If this\n          // is the case, abort here since next task (if any) is already being\n          // executed.\n          if (pendingTask.completed) {\n            return;\n          }\n          pendingTask.completed = true;\n          // Remove the task from the queue.\n          this.pendingTasks.delete(pendingTask.id);\n          logger.debug(`resolving task [name:${pendingTask.name}]`);\n          // Resolve the task with the obtained result.\n          resolve(result);\n          // Execute the next pending task (if any).\n          const [nextPendingTask] = this.pendingTasks.values();\n          // NOTE: During the resolve() callback the user app may have interacted\n          // with the queue. For instance, the app may have pushed a task while\n          // the queue was empty so such a task is already being executed. If so,\n          // don't execute it twice.\n          if (nextPendingTask && !nextPendingTask.executedAt) {\n            void this.execute(nextPendingTask);\n          }\n        },\n        reject: error => {\n          // pendingTask.reject() can be called within execute() method if the\n          // task completed with error. However it may have also been called in\n          // stop() or remove() methods (before or while being executed) so its\n          // completed flag was already set. If so, abort here since next task\n          // (if any) is already being executed.\n          if (pendingTask.completed) {\n            return;\n          }\n          pendingTask.completed = true;\n          // Remove the task from the queue.\n          this.pendingTasks.delete(pendingTask.id);\n          logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));\n          // Reject the task with the obtained error.\n          reject(error);\n          // Execute the next pending task (if any) unless stop() is running.\n          if (!this.stopping) {\n            const [nextPendingTask] = this.pendingTasks.values();\n            // NOTE: During the reject() callback the user app may have interacted\n            // with the queue. For instance, the app may have pushed a task while\n            // the queue was empty so such a task is already being executed. If so,\n            // don't execute it twice.\n            if (nextPendingTask && !nextPendingTask.executedAt) {\n              void this.execute(nextPendingTask);\n            }\n          }\n        }\n      };\n      // Append task to the queue.\n      this.pendingTasks.set(pendingTask.id, pendingTask);\n      // And execute it if this is the only task in the queue.\n      if (this.pendingTasks.size === 1) {\n        void this.execute(pendingTask);\n      }\n    });\n  }\n  stop() {\n    logger.debug('stop()');\n    this.stopping = true;\n    for (const pendingTask of this.pendingTasks.values()) {\n      logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);\n      pendingTask.reject(new errors_1.AwaitQueueStoppedError());\n    }\n    this.stopping = false;\n  }\n  remove(taskIdx) {\n    logger.debug(`remove() [taskIdx:${taskIdx}]`);\n    const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];\n    if (!pendingTask) {\n      logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);\n      return;\n    }\n    pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError());\n  }\n  dump() {\n    const now = Date.now();\n    let idx = 0;\n    return Array.from(this.pendingTasks.values()).map(pendingTask => ({\n      idx: idx++,\n      task: pendingTask.task,\n      name: pendingTask.name,\n      enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,\n      executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0\n    }));\n  }\n  async execute(pendingTask) {\n    logger.debug(`execute() [name:${pendingTask.name}]`);\n    if (pendingTask.executedAt) {\n      throw new Error('task already being executed');\n    }\n    pendingTask.executedAt = Date.now();\n    try {\n      const result = await pendingTask.task();\n      // Resolve the task with its resolved result (if any).\n      pendingTask.resolve(result);\n    } catch (error) {\n      // Reject the task with its rejected error.\n      pendingTask.reject(error);\n    }\n  }\n}\nexports.AwaitQueue = AwaitQueue;","map":{"version":3,"names":["Object","defineProperty","exports","value","AwaitQueue","Logger_1","require","errors_1","logger","Logger","pendingTasks","Map","nextTaskId","stopping","constructor","debug","size","push","task","name","TypeError","error","Promise","resolve","reject","pendingTask","id","enqueuedAt","Date","now","executedAt","undefined","completed","result","delete","nextPendingTask","values","execute","String","set","stop","AwaitQueueStoppedError","remove","taskIdx","Array","from","AwaitQueueRemovedTaskError","dump","idx","map","enqueuedTime","executionTime","Error"],"sources":["/Users/user/turn/turn-front/node_modules/awaitqueue/lib/AwaitQueue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AwaitQueue = void 0;\nconst Logger_1 = require(\"./Logger\");\nconst errors_1 = require(\"./errors\");\nconst logger = new Logger_1.Logger('AwaitQueue');\nclass AwaitQueue {\n    // Queue of pending tasks (map of PendingTasks indexed by id).\n    pendingTasks = new Map();\n    // Incrementing PendingTask id.\n    nextTaskId = 0;\n    // Whether stop() method is stopping all pending tasks.\n    stopping = false;\n    constructor() {\n        logger.debug('constructor()');\n    }\n    get size() {\n        return this.pendingTasks.size;\n    }\n    async push(task, name) {\n        name = name ?? task.name;\n        logger.debug(`push() [name:${name}]`);\n        if (typeof task !== 'function') {\n            throw new TypeError('given task is not a function');\n        }\n        if (name) {\n            try {\n                Object.defineProperty(task, 'name', { value: name });\n            }\n            catch (error) { }\n        }\n        return new Promise((resolve, reject) => {\n            const pendingTask = {\n                id: this.nextTaskId++,\n                task: task,\n                name: name,\n                enqueuedAt: Date.now(),\n                executedAt: undefined,\n                completed: false,\n                resolve: (result) => {\n                    // pendingTask.resolve() can only be called in execute() method. Since\n                    // resolve() was called it means that the task successfully completed.\n                    // However the task may have been stopped before it completed (via\n                    // stop() or remove()) so its completed flag was already set. If this\n                    // is the case, abort here since next task (if any) is already being\n                    // executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`resolving task [name:${pendingTask.name}]`);\n                    // Resolve the task with the obtained result.\n                    resolve(result);\n                    // Execute the next pending task (if any).\n                    const [nextPendingTask] = this.pendingTasks.values();\n                    // NOTE: During the resolve() callback the user app may have interacted\n                    // with the queue. For instance, the app may have pushed a task while\n                    // the queue was empty so such a task is already being executed. If so,\n                    // don't execute it twice.\n                    if (nextPendingTask && !nextPendingTask.executedAt) {\n                        void this.execute(nextPendingTask);\n                    }\n                },\n                reject: (error) => {\n                    // pendingTask.reject() can be called within execute() method if the\n                    // task completed with error. However it may have also been called in\n                    // stop() or remove() methods (before or while being executed) so its\n                    // completed flag was already set. If so, abort here since next task\n                    // (if any) is already being executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));\n                    // Reject the task with the obtained error.\n                    reject(error);\n                    // Execute the next pending task (if any) unless stop() is running.\n                    if (!this.stopping) {\n                        const [nextPendingTask] = this.pendingTasks.values();\n                        // NOTE: During the reject() callback the user app may have interacted\n                        // with the queue. For instance, the app may have pushed a task while\n                        // the queue was empty so such a task is already being executed. If so,\n                        // don't execute it twice.\n                        if (nextPendingTask && !nextPendingTask.executedAt) {\n                            void this.execute(nextPendingTask);\n                        }\n                    }\n                },\n            };\n            // Append task to the queue.\n            this.pendingTasks.set(pendingTask.id, pendingTask);\n            // And execute it if this is the only task in the queue.\n            if (this.pendingTasks.size === 1) {\n                void this.execute(pendingTask);\n            }\n        });\n    }\n    stop() {\n        logger.debug('stop()');\n        this.stopping = true;\n        for (const pendingTask of this.pendingTasks.values()) {\n            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);\n            pendingTask.reject(new errors_1.AwaitQueueStoppedError());\n        }\n        this.stopping = false;\n    }\n    remove(taskIdx) {\n        logger.debug(`remove() [taskIdx:${taskIdx}]`);\n        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];\n        if (!pendingTask) {\n            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);\n            return;\n        }\n        pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError());\n    }\n    dump() {\n        const now = Date.now();\n        let idx = 0;\n        return Array.from(this.pendingTasks.values()).map(pendingTask => ({\n            idx: idx++,\n            task: pendingTask.task,\n            name: pendingTask.name,\n            enqueuedTime: pendingTask.executedAt\n                ? pendingTask.executedAt - pendingTask.enqueuedAt\n                : now - pendingTask.enqueuedAt,\n            executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0,\n        }));\n    }\n    async execute(pendingTask) {\n        logger.debug(`execute() [name:${pendingTask.name}]`);\n        if (pendingTask.executedAt) {\n            throw new Error('task already being executed');\n        }\n        pendingTask.executedAt = Date.now();\n        try {\n            const result = await pendingTask.task();\n            // Resolve the task with its resolved result (if any).\n            pendingTask.resolve(result);\n        }\n        catch (error) {\n            // Reject the task with its rejected error.\n            pendingTask.reject(error);\n        }\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}